/*
 * coreMQTT <DEVELOPMENT BRANCH>
 * Copyright (C) 2022 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * @file core_mqtt_serializer.c
 * @brief Implements the user-facing functions in core_mqtt_serializer.h.
 */
#include <string.h>
#include <assert.h>

#include "core_mqtt_serializer.h"

/* Include config defaults header to get default values of configs. */
#include "core_mqtt_config_defaults.h"

/**
 * @brief MQTT protocol version 3.1.1.
 */
#define MQTT_VERSION_3_1_1                          ( ( uint8_t ) 4U )

/**
 * @brief Size of the fixed and variable header of a CONNECT packet.
 */
#define MQTT_PACKET_CONNECT_HEADER_SIZE             ( 10UL )

/* MQTT CONNECT flags. */
#define MQTT_CONNECT_FLAG_CLEAN                     ( 1 ) /**< @brief Clean session. */
#define MQTT_CONNECT_FLAG_WILL                      ( 2 ) /**< @brief Will present. */
#define MQTT_CONNECT_FLAG_WILL_QOS1                 ( 3 ) /**< @brief Will QoS 1. */
#define MQTT_CONNECT_FLAG_WILL_QOS2                 ( 4 ) /**< @brief Will QoS 2. */
#define MQTT_CONNECT_FLAG_WILL_RETAIN               ( 5 ) /**< @brief Will retain. */
#define MQTT_CONNECT_FLAG_PASSWORD                  ( 6 ) /**< @brief Password present. */
#define MQTT_CONNECT_FLAG_USERNAME                  ( 7 ) /**< @brief User name present. */

/*
 * Positions of each flag in the first byte of an MQTT PUBLISH packet's
 * fixed header.
 */
#define MQTT_PUBLISH_FLAG_RETAIN                    ( 0 ) /**< @brief MQTT PUBLISH retain flag. */
#define MQTT_PUBLISH_FLAG_QOS1                      ( 1 ) /**< @brief MQTT PUBLISH QoS1 flag. */
#define MQTT_PUBLISH_FLAG_QOS2                      ( 2 ) /**< @brief MQTT PUBLISH QoS2 flag. */
#define MQTT_PUBLISH_FLAG_DUP                       ( 3 ) /**< @brief MQTT PUBLISH duplicate flag. */

/**
 * @brief The size of MQTT DISCONNECT packets, per MQTT spec.
 */
#define MQTT_DISCONNECT_PACKET_SIZE                 ( 2UL )

/**
 * @brief A PINGREQ packet is always 2 bytes in size, defined by MQTT 3.1.1 spec.
 */
#define MQTT_PACKET_PINGREQ_SIZE                    ( 2UL )

/**
 * @brief The Remaining Length field of MQTT disconnect packets, per MQTT spec.
 */
#define MQTT_DISCONNECT_REMAINING_LENGTH            ( ( uint8_t ) 0 )

/*
 * Constants relating to CONNACK packets, defined by MQTT 3.1.1 spec.
 */
#define MQTT_PACKET_CONNACK_REMAINING_LENGTH        ( ( uint8_t ) 2U )    /**< @brief A CONNACK packet always has a "Remaining length" of 2. */
#define MQTT_PACKET_CONNACK_SESSION_PRESENT_MASK    ( ( uint8_t ) 0x01U ) /**< @brief The "Session Present" bit is always the lowest bit. */

/*
 * UNSUBACK, PUBACK, PUBREC, PUBREL, and PUBCOMP always have a remaining length
 * of 2.
 */
#define MQTT_PACKET_SIMPLE_ACK_REMAINING_LENGTH     ( ( uint8_t ) 2 ) /**< @brief PUBACK, PUBREC, PUBREl, PUBCOMP, UNSUBACK Remaining length. */
#define MQTT_PACKET_PINGRESP_REMAINING_LENGTH       ( 0U )            /**< @brief A PINGRESP packet always has a "Remaining length" of 0. */

/**
 * @brief Per the MQTT 3.1.1 spec, the largest "Remaining Length" of an MQTT
 * packet is this value, 256 MB.
 */
#define MQTT_MAX_REMAINING_LENGTH                   ( 268435455UL )

/**
 * @brief Per the MQTT spec, the max packet size can be of max remaining length + 5 bytes.
 * Fixed header 
 *    MQTT packet type nibble + MQTT flags nibble             1
 *    Maximum bytes used to encode the remaining length       4
 */
#define MQTT_MAX_PACKET_SIZE                        ( MQTT_MAX_REMAINING_LENGTH + 5U )

/**
 * @brief Set a bit in an 8-bit unsigned integer.
 */
#define UINT8_SET_BIT( x, position )      ( ( x ) = ( uint8_t ) ( ( x ) | ( 0x01U << ( position ) ) ) )

/**
 * @brief Clear a bit in an 8-bit unsigned integer.
 */
#define UINT8_CLEAR_BIT( x, position )    ( ( x ) = ( uint8_t ) ( ( x ) & ( ~( 0x01U << ( position ) ) ) ) )

/**
 * @brief Macro for checking if a bit is set in a 1-byte unsigned int.
 *
 * @param[in] x The unsigned int to check.
 * @param[in] position Which bit to check.
 */
#define UINT8_CHECK_BIT( x, position )    ( ( ( x ) & ( 0x01U << ( position ) ) ) == ( 0x01U << ( position ) ) )

/**
 * @brief Get the high byte of a 16-bit unsigned integer.
 */
#define UINT16_HIGH_BYTE( x )             ( ( uint8_t ) ( ( x ) >> 8 ) )

/**
 * @brief Get the low byte of a 16-bit unsigned integer.
 */
#define UINT16_LOW_BYTE( x )              ( ( uint8_t ) ( ( x ) & 0x00ffU ) )

/**
 * @brief Macro for decoding a 2-byte unsigned int from a sequence of bytes.
 *
 * @param[in] ptr A uint8_t* that points to the high byte.
 */
#define UINT16_DECODE( ptr )                            \
    ( uint16_t ) ( ( ( ( uint16_t ) ptr[ 0 ] ) << 8 ) | \
                   ( ( uint16_t ) ptr[ 1 ] ) )

/**
 * @brief Set a bit in an 32-bit unsigned integer.
 */
#define UINT32_SET_BIT( x, position ) \
    ( ( x ) = ( uint32_t ) ( ( x ) | ( ( uint32_t ) 0x01U << ( position ) ) ) )

/**
 * @brief Macro for checking if a bit is set in a 4-byte unsigned int.
 *
 * @param[in] x The unsigned int to check.
 * @param[in] position Which bit to check.
 */
#define UINT32_CHECK_BIT( x, position ) \
    ( ( ( uint32_t ) ( x ) &( ( uint32_t ) 0x01U << ( position ) ) ) == ( ( uint32_t ) 0x01U << ( position ) ) )

/**
 * @brief A value that represents an invalid remaining length.
 *
 * This value is greater than what is allowed by the MQTT specification.
 */
#define MQTT_REMAINING_LENGTH_INVALID             ( ( size_t ) 268435456 )

/**
 * @brief The minimum remaining length for a QoS 0 PUBLISH.
 *
 * Includes two bytes for topic name length and one byte for topic name.
 */
#define MQTT_MIN_PUBLISH_REMAINING_LENGTH_QOS0    ( 3U )

/**
 * @brief A PINGREQ packet is always 2 bytes in size, defined by MQTT 5.0 spec.
 */
#define MQTT_PACKET_PINGREQ_SIZE                    ( 2UL )

/*
 * Constants relating to CONNACK packets, defined by MQTT spec.
 */
#define MQTT_PACKET_CONNACK_SESSION_PRESENT_MASK    ( ( uint8_t ) 0x01U ) /**< @brief The "Session Present" bit is always the lowest bit. */

/**
 * @brief Minimum Length of PUBACK, PUBREC, PUBREL, PUBCOMP Packets
 */
#define MQTT_PACKET_SIMPLE_ACK_REMAINING_LENGTH     ( ( uint8_t ) 2 )

/**
 * @brief A PINGRESP packet always has a "Remaining length" of 0. */
#define MQTT_PACKET_PINGRESP_REMAINING_LENGTH       ( 0U )

/**
 * @brief Version 5 has the value 5.
 */
#define MQTT_VERSION_5                              ( 5U )

/**
 * @ingroup mqtt_constants
 * @brief The size of MQTT PUBACK, PUBREC, PUBREL, and PUBCOMP packets with reason code, packet id.
 */
#define MQTT_PUBLISH_ACK_PACKET_SIZE_WITH_REASON    ( 3UL )

/**
 * @brief Minimum number of bytes in the CONNACK Packet.
 * CONNECT Acknowledge Flags    0 + 1 = 1
 * CONNECT Reason Code            + 1 = 2
 * Property Length byte (min)     + 1 = 3
 */
#define MQTT_PACKET_CONNACK_MINIMUM_SIZE            ( 3U )

/**
 * @brief Position of the properties for the fieldSet.
 *
 * Each property that can be added to an MQTT packet is assigned a unique bit
 * position (0â€“31). This macro defines the position of the property
 * in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 *
 * The `fieldSet` is used to track which properties have already been added to prevent
 * duplication, as many MQTT v5 properties must not appear more than once in a packet.
 */

/**
 * @brief Defines the position of the **Subscription Identifier**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_SUBSCRIPTION_ID_POS             ( 1 )

/**
 * @brief Defines the position of the **Session Expiry Interval**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_SESSION_EXPIRY_INTERVAL_POS     ( 2 )

/**
 * @brief Defines the position of the **Receive Maximum**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_RECEIVE_MAXIMUM_POS             ( 3 )

/**
 * @brief Defines the position of the **Maximum Packet Size**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_MAX_PACKET_SIZE_POS             ( 4 )

/**
 * @brief Defines the position of the **Topic Alias Maximum**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_TOPIC_ALIAS_MAX_POS             ( 5 )

/**
 * @brief Defines the position of the **Request Response Information**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_REQUEST_RESPONSE_INFO_POS       ( 6 )

/**
 * @brief Defines the position of the **Request Problem Information**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_REQUEST_PROBLEM_INFO_POS        ( 7 )

/**
 * @brief Defines the position of the **Authentication Method**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_AUTHENTICATION_METHOD_POS       ( 9 )

/**
 * @brief Defines the position of the **Authentication Data**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_AUTHENTICATION_DATA_POS         ( 10 )

/**
 * @brief Defines the position of the **Payload Format Indicator**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_PAYLOAD_FORMAT_INDICATOR_POS    ( 11 )

/**
 * @brief Defines the position of the **Message Expiry Interval**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_MESSAGE_EXPIRY_INTERVAL_POS     ( 12 )

/**
 * @brief Defines the position of the **Topic Alias**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_TOPIC_ALIAS_POS                 ( 13 )

/**
 * @brief Defines the position of the **Response Topic**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_RESPONSE_TOPIC_POS              ( 14 )

/**
 * @brief Defines the position of the **Correlation Data**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_CORRELATION_DATA_POS            ( 15 )

/**
 * @brief Defines the position of the **Content Type**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_CONTENT_TYPE_POS                ( 16 )

/**
 * @brief Defines the position of the **Reason String**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_REASON_STRING_POS               ( 17 )

/**
 * @brief Defines the position of the **Will Delay Interval**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_WILL_DELAY_POS                  ( 18 )

/**
 * @brief Defines the position of the **Assigned Client Identifier**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_ASSIGNED_CLIENT_ID_POS          ( 19 )

/**
 * @brief Defines the position of the **Server Keep Alive**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_SERVER_KEEP_ALIVE_POS           ( 20 )

/**
 * @brief Defines the position of the **Response Information**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_RESPONSE_INFORMATION_POS        ( 21 )

/**
 * @brief Defines the position of the **Server Reference**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_SERVER_REFERENCE_POS            ( 22 )

/**
 * @brief Defines the position of the **Maximum QoS**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_MAXIMUM_QOS_POS                 ( 23 )

/**
 * @brief Defines the position of the **Retain Available**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_RETAIN_AVAILABLE_POS            ( 24 )

/**
 * @brief Defines the position of the **Wildcard Subscription Available**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_WILDCARD_SUBSCRIPTION_AVAILABLE_POS  ( 25 )

/**
 * @brief Defines the position of the **Subscription Identifier Available**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_SUBSCRIPTION_ID_AVAILABLE_POS   ( 26 )

/**
 * @brief Defines the position of the **Shared Subscription Available**
 * property in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_SHARED_SUBSCRIPTION_AVAILABLE_POS  ( 27 )

/**
 * @brief Defines the position of the **User property**
 * in the `fieldSet` bitfield of the `MQTTPropBuilder_t` struct.
 */
#define MQTT_USER_PROP_POS  ( 28 )


/**
 * @brief A value that represents an invalid remaining length.
 *
 * This value is greater than what is allowed by the MQTT specification.
 */
#define MQTT_REMAINING_LENGTH_INVALID        ( ( size_t ) 268435456 )

/**
 * This macro serializes a 32-bit unsigned integer (`val`) into 4 bytes at the
 * specified memory location (`addr`).
 */
#define WRITE_UINT32( addr, val )                                  \
    {                                                              \
        ( addr )[ 3 ] = ( uint8_t ) ( ( ( val ) >> 0 ) & 0xFFU );  \
        ( addr )[ 2 ] = ( uint8_t ) ( ( ( val ) >> 8 ) & 0xFFU );  \
        ( addr )[ 1 ] = ( uint8_t ) ( ( ( val ) >> 16 ) & 0xFFU ); \
        ( addr )[ 0 ] = ( uint8_t ) ( ( ( val ) >> 24 ) & 0xFFU ); \
    }

/*-----------------------------------------------------------*/


/**
 * @brief MQTT Subscription packet types.
 */
typedef enum MQTTSubscriptionType
{
    MQTT_SUBSCRIBE,  /**< @brief The type is a SUBSCRIBE packet. */
    MQTT_UNSUBSCRIBE /**< @brief The type is a UNSUBSCRIBE packet. */
} MQTTSubscriptionType_t;

/*-----------------------------------------------------------*/

/**
 * @brief Serializes MQTT PUBLISH packet into the buffer provided.
 *
 * This function serializes MQTT PUBLISH packet into #MQTTFixedBuffer_t.pBuffer.
 * Copy of the payload into the buffer is done as part of the serialization
 * only if @p serializePayload is true.
 *
 * @brief param[in] pPublishInfo Publish information.
 * @brief param[in] remainingLength Remaining length of the PUBLISH packet.
 * @brief param[in] packetIdentifier Packet identifier of PUBLISH packet.
 * @brief param[in, out] pFixedBuffer Buffer to which PUBLISH packet will be
 * serialized.
 * @brief param[in] serializePayload Copy payload to the serialized buffer
 * only if true. Only PUBLISH header will be serialized if false.
 */
static void serializePublishCommon( const MQTTPublishInfo_t * pPublishInfo,
                                    size_t remainingLength,
                                    uint16_t packetIdentifier,
                                    const MQTTFixedBuffer_t * pFixedBuffer,
                                    bool serializePayload );

/**
 * @brief Calculates the packet size and remaining length of an MQTT
 * PUBLISH packet.
 *
 * @param[in] pPublishInfo MQTT PUBLISH packet parameters.
 * @param[out] pRemainingLength The Remaining Length of the MQTT PUBLISH packet.
 * @param[out] pPacketSize The total size of the MQTT PUBLISH packet.
 *
 * @return false if the packet would exceed the size allowed by the
 * MQTT spec; true otherwise.
 */
static bool calculatePublishPacketSize( const MQTTPublishInfo_t * pPublishInfo,
                                        size_t * pRemainingLength,
                                        size_t * pPacketSize );

/**
 * @brief Calculates the packet size and remaining length of an MQTT
 * SUBSCRIBE or UNSUBSCRIBE packet.
 *
 * @param[in] pSubscriptionList List of MQTT subscription info.
 * @param[in] subscriptionCount The number of elements in pSubscriptionList.
 * @param[out] pRemainingLength The Remaining Length of the MQTT SUBSCRIBE or
 * UNSUBSCRIBE packet.
 * @param[out] pPacketSize The total size of the MQTT MQTT SUBSCRIBE or
 * UNSUBSCRIBE packet.
 * @param[in] subscriptionType #MQTT_SUBSCRIBE or #MQTT_UNSUBSCRIBE.
 *
 * #MQTTBadParameter if the packet would exceed the size allowed by the
 * MQTT spec or a subscription is empty; #MQTTSuccess otherwise.
 */
static MQTTStatus_t calculateSubscriptionPacketSize( const MQTTSubscribeInfo_t * pSubscriptionList,
                                                     size_t subscriptionCount,
                                                     size_t * pRemainingLength,
                                                     size_t * pPacketSize,
                                                     MQTTSubscriptionType_t subscriptionType );

/**
 * @brief Validates parameters of #MQTT_SerializeSubscribe or
 * #MQTT_SerializeUnsubscribe.
 *
 * @param[in] pSubscriptionList List of MQTT subscription info.
 * @param[in] subscriptionCount The number of elements in pSubscriptionList.
 * @param[in] packetId Packet identifier.
 * @param[in] remainingLength Remaining length of the packet.
 * @param[in] pFixedBuffer Buffer for packet serialization.
 *
 * @return #MQTTNoMemory if pBuffer is too small to hold the MQTT packet;
 * #MQTTBadParameter if invalid parameters are passed;
 * #MQTTSuccess otherwise.
 */
static MQTTStatus_t validateSubscriptionSerializeParams( const MQTTSubscribeInfo_t * pSubscriptionList,
                                                         size_t subscriptionCount,
                                                         uint16_t packetId,
                                                         size_t remainingLength,
                                                         const MQTTFixedBuffer_t * pFixedBuffer );

/**
 * @brief Serialize an MQTT CONNECT packet in the given buffer.
 *
 * @param[in] pConnectInfo MQTT CONNECT packet parameters.
 * @param[in] pWillInfo Last Will and Testament. Pass NULL if not used.
 * @param[in] remainingLength Remaining Length of MQTT CONNECT packet.
 * @param[out] pFixedBuffer Buffer for packet serialization.
 */
static void serializeConnectPacket( const MQTTConnectInfo_t * pConnectInfo,
                                    const MQTTPublishInfo_t * pWillInfo,
                                    size_t remainingLength,
                                    const MQTTFixedBuffer_t * pFixedBuffer );

/**
 * @brief Prints the appropriate message for the CONNACK response code if logs
 * are enabled.
 *
 * @param[in] responseCode MQTT standard CONNACK response code.
 */
static void logConnackResponse( uint8_t responseCode );

/**
 * @brief Encodes the remaining length of the packet using the variable length
 * encoding scheme provided in the MQTT v3.1.1 specification.
 *
 * @param[out] pDestination The destination buffer to store the encoded remaining
 * length.
 * @param[in] length The remaining length to encode.
 *
 * @return The location of the byte following the encoded value.
 */
static uint8_t * encodeRemainingLength( uint8_t * pDestination,
                                        size_t length );

/**
 * @brief Retrieve the size of the remaining length if it were to be encoded.
 *
 * @param[in] length The remaining length to be encoded.
 *
 * @return The size of the remaining length if it were to be encoded.
 */
static size_t remainingLengthEncodedSize( size_t length );

/**
 * @brief Encode a string whose size is at maximum 16 bits in length.
 *
 * @param[out] pDestination Destination buffer for the encoding.
 * @param[in] pSource The source string to encode.
 * @param[in] sourceLength The length of the source string to encode.
 *
 * @return A pointer to the end of the encoded string.
 */
static uint8_t * encodeString( uint8_t * pDestination,
                               const char * pSource,
                               uint16_t sourceLength );

/**
 * @brief Retrieves and decodes the Remaining Length from the network interface
 * by reading a single byte at a time.
 *
 * @param[in] recvFunc Network interface receive function.
 * @param[in] pNetworkContext Network interface context to the receive function.
 *
 * @return The Remaining Length of the incoming packet.
 */
static size_t getRemainingLength( TransportRecv_t recvFunc,
                                  NetworkContext_t * pNetworkContext );

/**
 * @brief Retrieves, decodes and stores the Remaining Length from the network
 * interface by reading a single byte at a time.
 *
 * @param[in] pBuffer The buffer holding the raw data to be processed
 * @param[in] pIndex Pointer to the index within the buffer to marking the end of raw data
 *            available.
 * @param[in] pIncomingPacket Structure used to hold the fields of the
 *            incoming packet.
 *
 * @return MQTTNeedMoreBytes is returned to show that the incoming
 *         packet is not yet fully received and decoded. Otherwise, MQTTSuccess
 *         shows that processing of the packet was successful.
 */
static MQTTStatus_t processRemainingLength( const uint8_t * pBuffer,
                                            const size_t * pIndex,
                                            MQTTPacketInfo_t * pIncomingPacket );

/**
 * @brief Check if an incoming packet type is valid.
 *
 * @param[in] packetType The packet type to check.
 *
 * @return `true` if the packet type is valid; `false` otherwise.
 */
static bool incomingPacketValid( uint8_t packetType );

/**
 * @brief Check the remaining length of an incoming PUBLISH packet against some
 * value for QoS 0, or for QoS 1 and 2.
 *
 * The remaining length for a QoS 1 and 2 packet will always be two greater than
 * for a QoS 0.
 *
 * @param[in] remainingLength Remaining length of the PUBLISH packet.
 * @param[in] qos The QoS of the PUBLISH.
 * @param[in] qos0Minimum Minimum possible remaining length for a QoS 0 PUBLISH.
 *
 * @return #MQTTSuccess or #MQTTBadResponse.
 */
static MQTTStatus_t checkPublishRemainingLength( size_t remainingLength,
                                                 MQTTQoS_t qos,
                                                 size_t qos0Minimum );

/**
 * @brief Process the flags of an incoming PUBLISH packet.
 *
 * @param[in] publishFlags Flags of an incoming PUBLISH.
 * @param[in, out] pPublishInfo Pointer to #MQTTPublishInfo_t struct where
 * output will be written.
 *
 * @return #MQTTSuccess or #MQTTBadResponse.
 */
static MQTTStatus_t processPublishFlags( uint8_t publishFlags,
                                         MQTTPublishInfo_t * pPublishInfo );

/**
 * @brief Deserialize an MQTT CONNACK packet.
 *
 * @param[out] pConnackProperties To store the deserialized connack properties.
 * @param[in]  pIncomingPacket #MQTTPacketInfo_t containing the buffer.
 * @param[out]  pSessionPresent Whether a previous session was present.
 * @param[out]  pPropBuffer MQTTPropBuilder_t to store the deserialized properties.
 *
 * @return #MQTTBadParameter, #MQTTBadResponse, #MQTTSuccess, #MQTTServerRefused
 */
static MQTTStatus_t deserializeConnack( MQTTConnectionProperties_t * pConnackProperties,
                                        const MQTTPacketInfo_t * pIncomingPacket,
                                        bool * pSessionPresent,
                                        MQTTPropBuilder_t * pPropBuffer );

/**
 * @brief Decode the status bytes of a SUBACK packet to a #MQTTStatus_t.
 *
 * @param[in] statusCount Number of status bytes in the SUBACK.
 * @param[in] pStatusStart The first status byte in the SUBACK.
 *
 * @return #MQTTSuccess, #MQTTServerRefused, or #MQTTBadResponse.
 */
static MQTTStatus_t readSubackStatus( size_t statusCount,
                                      const uint8_t * pStatusStart );

/**
 * @brief Deserialize a SUBACK packet.
 *
 * Converts the packet from a stream of bytes to an #MQTTStatus_t and extracts
 * the packet identifier.
 *
 * @param[in] pSuback Pointer to an MQTT packet struct representing a SUBACK.
 * @param[out] pPacketIdentifier Packet ID of the SUBACK.
 *
 * @return #MQTTSuccess if SUBACK is valid; #MQTTBadResponse if SUBACK packet
 * doesn't follow the MQTT spec.
 */
static MQTTStatus_t deserializeSuback( const MQTTPacketInfo_t * pSuback,
                                       uint16_t * pPacketIdentifier );

/**
 * @brief Deserialize a PUBLISH packet received from the server.
 *
 * Converts the packet from a stream of bytes to an #MQTTPublishInfo_t and
 * extracts the packet identifier. Also prints out debug log messages about the
 * packet.
 *
 * @param[in] pIncomingPacket Pointer to an MQTT packet struct representing a
 * PUBLISH.
 * @param[out] pPacketId Packet identifier of the PUBLISH.
 * @param[out] pPublishInfo Pointer to #MQTTPublishInfo_t where output is
 * written.
 *
 * @return #MQTTSuccess if PUBLISH is valid; #MQTTBadResponse
 * if the PUBLISH packet doesn't follow MQTT spec.
 */
static MQTTStatus_t deserializePublish( const MQTTPacketInfo_t * pIncomingPacket,
                                        uint16_t * pPacketId,
                                        MQTTPublishInfo_t * pPublishInfo );

/**
 * @brief Deserialize an UNSUBACK, PUBACK, PUBREC, PUBREL, or PUBCOMP packet.
 *
 * Converts the packet from a stream of bytes to an #MQTTStatus_t and extracts
 * the packet identifier.
 *
 * @param[in] pAck Pointer to the MQTT packet structure representing the packet.
 * @param[out] pPacketIdentifier Packet ID of the ack type packet.
 *
 * @return #MQTTSuccess if UNSUBACK, PUBACK, PUBREC, PUBREL, or PUBCOMP is valid;
 * #MQTTBadResponse if the packet doesn't follow the MQTT spec.
 */
static MQTTStatus_t deserializeSimpleAck( const MQTTPacketInfo_t * pAck,
                                          uint16_t * pPacketIdentifier );

/**
 * @brief Deserialize a PINGRESP packet.
 *
 * Converts the packet from a stream of bytes to an #MQTTStatus_t.
 *
 * @param[in] pPingresp Pointer to an MQTT packet struct representing a PINGRESP.
 *
 * @return #MQTTSuccess if PINGRESP is valid; #MQTTBadResponse if the PINGRESP
 * packet doesn't follow MQTT spec.
 */
static MQTTStatus_t deserializePingresp( const MQTTPacketInfo_t * pPingresp );

/**
 * @brief Validate the connack parameters.
 *
 * Converts the packet from a stream of bytes to an #MQTTStatus_t and extracts
 * the variable header without connack properties.
 *
 * @param[in] pIncomingPacket Pointer to an MQTT packet struct representing a incoming packet.
 * @param[out] pSessionPresent Whether a session is present or not.
 *
 *
 * @return #MQTTSuccess if connack  without connack properties is valid;
 * #MQTTServerRefused if the server refused the connection;
 * #MQTTBadResponse if the Connack packet doesn't follow MQTT spec.
 */
static MQTTStatus_t validateConnackParams( const MQTTPacketInfo_t * pIncomingPacket,
                                           bool * pSessionPresent );

/**
 * @brief Validate the length and decode a 4 byte value.
 *
 * @param[out] pProperty To store the decoded property.
 * @param[in, out] pPropertyLength  Value of the remaining property length.
 * @param[in, out] pUsed Whether the property is decoded before.
 * @param[in, out] pIndex Pointer to the current index of the buffer.
 *
 * @return #MQTTSuccess, #MQTTBadResponse
 **/
static MQTTStatus_t decodeUint32t( uint32_t * pProperty,
                                    size_t * pPropertyLength,
                                    bool * pUsed,
                                    uint8_t ** pIndex );

/**
 * @brief Validate the length and decode a 2 byte value.
 *
 * @param[out] pProperty To store the decoded property.
 * @param[in, out] pPropertyLength  Value of the remaining property length.
 * @param[in, out] pUsed Whether the property is decoded before.
 * @param[in, out]  pIndex Pointer to the current index of the buffer.
 *
 * @return #MQTTSuccess, #MQTTBadResponse
 **/

static MQTTStatus_t decodeUint16t( uint16_t * pProperty,
                                    size_t * pPropertyLength,
                                    bool * pUsed,
                                    uint8_t ** pIndex );

/**
 * @brief Validate the length and decode a 1 byte value.
 *
 * @param[out] pProperty To store the decoded property.
 * @param[in, out] pPropertyLength  Value of the remaining property length.
 * @param[in, out] pUsed Whether the property is decoded before.
 * @param[in, out]  pIndex Pointer to the current index of the buffer.
 *
 * @return #MQTTSuccess, #MQTTBadResponse
 **/
static MQTTStatus_t decodeUint8t( uint8_t * pProperty,
                                   size_t * pPropertyLength,
                                   bool * pUsed,
                                   uint8_t ** pIndex );

/**
 * @brief Validate the length and decode a utf 8 string.
 *
 * @param[out] pProperty To store the decoded string.
 * @param[out] pLength  Size of the decoded utf-8 string.
 * @param[in, out] pPropertyLength  Value of the remaining property length.
 * @param[in, out] pUsed Whether the property is decoded before.
 * @param[in, out]  pIndex Pointer to the current index of the buffer.
 *
 * @return #MQTTSuccess, #MQTTBadResponse
 **/
static MQTTStatus_t decodeUtf8( const char ** pProperty,
                                 uint16_t * pLength,
                                 size_t * pPropertyLength,
                                 bool * pUsed,
                                 uint8_t ** pIndex );

/**
 * @brief Validate the length and decode a user property.
 *
 * @param[out] pPropertyKey To store the decoded key.
 * @param[out] pPropertyKeyLen To store the decoded key length.
 * @param[out] pPropertyValue To store the decoded value.
 * @param[out] pPropertyValueLen To store the decoded value length.
 * @param[in, out] pPropertyLength  Value of the remaining property length.
 * @param[in, out] pIndex Pointer to the current index of the buffer.
 *
 * @return #MQTTSuccess, #MQTTBadResponse
 **/
 static MQTTStatus_t decodeUserProp( const char ** pPropertyKey,
                                     uint16_t * pPropertyKeyLen,
                                     const char ** pPropertyValue,
                                     uint16_t * pPropertyValueLen,
                                     size_t * pPropertyLength,
                                     uint8_t ** pIndex );

/**
 * @brief Validate the length and decode the connack properties.
 *
 * @param[out] pConnackProperties To store the decoded property.
 * @param[in] length  Length of the properties.
 * @param[in] pIndex Pointer to the start of the properties.
 * @param[out] pPropBuffer Pointer to the property buffer.
 *
 * @return #MQTTSuccess, #MQTTBadResponse
 **/
static MQTTStatus_t deserializeConnackProperties( MQTTConnectionProperties_t * pConnackProperties,
                                                  size_t length,
                                                  uint8_t * pIndex,
                                                  MQTTPropBuilder_t * pPropBuffer );

/**
 * @brief Decodes the variable length by reading a single byte at a time.
 *
 * Uses the algorithm provided in the spec.
 *
 * @param[in] pBuffer Pointer to the buffer.
 * @param[in] bufferLength Length of the remaining buffer.
 * @param[out] pLength Decoded variable length
 *
 * @return #MQTTSuccess if variable length and paramters are valid else #MQTTBadResponse.
 */
static MQTTStatus_t decodeVariableLength( const uint8_t * pBuffer,
                                          size_t bufferLength,
                                          size_t * pLength );

/**
 * @brief Retrieve the size of the remaining length if it were to be encoded.
 *
 * @param[in] length The remaining length to be encoded.
 *
 * @return The size of the remaining length if it were to be encoded.
 */
static size_t variableLengthEncodedSize( size_t length );

/**
 * @brief Encode binary data whose size is at maximum 16 bits in length.
 *
 * @param[out] pDestination Destination buffer for the encoding.
 * @param[in] pSource The source binary data to encode.
 * @param[in] sourceLength The length of the source data to encode.
 *
 * @return A pointer to the end of the encoded binary data.
 */
static uint8_t * encodeBinaryData( uint8_t * pDestination,
                                   const void * pSource,
                                   uint16_t sourceLength );

/**
 * @brief Check whether the provided property is allowed for a packet type.
 *
 * @param[in] mqttPacketType Packet type to check.
 * @param[in] propBitLocation Bit location of the property.
 *
 * @return Whether the property is allowed for the packet type.
 */
static bool isValidPropertyInPacketType( const uint8_t * mqttPacketType, uint8_t propBitLocation );

/*-----------------------------------------------------------*/

static size_t remainingLengthEncodedSize( size_t length )
{
    size_t encodedSize;

    /* Determine how many bytes are needed to encode length.
     * The values below are taken from the MQTT 3.1.1 spec. */

    /* 1 byte is needed to encode lengths between 0 and 127. */
    if( length < 128U )
    {
        encodedSize = 1U;
    }
    /* 2 bytes are needed to encode lengths between 128 and 16,383. */
    else if( length < 16384U )
    {
        encodedSize = 2U;
    }
    /* 3 bytes are needed to encode lengths between 16,384 and 2,097,151. */
    else if( length < 2097152U )
    {
        encodedSize = 3U;
    }
    /* 4 bytes are needed to encode lengths between 2,097,152 and 268,435,455. */
    else
    {
        encodedSize = 4U;
    }

    LogDebug( ( "Encoded size for length %lu is %lu bytes.",
                ( unsigned long ) length,
                ( unsigned long ) encodedSize ) );

    return encodedSize;
}

/*-----------------------------------------------------------*/

static uint8_t * encodeRemainingLength( uint8_t * pDestination,
                                        size_t length )
{
    uint8_t lengthByte;
    uint8_t * pLengthEnd = NULL;
    size_t remainingLength = length;

    assert( pDestination != NULL );

    pLengthEnd = pDestination;

    /* This algorithm is copied from the MQTT v3.1.1 spec. */
    do
    {
        lengthByte = ( uint8_t ) ( remainingLength % 128U );
        remainingLength = remainingLength / 128U;

        /* Set the high bit of this byte, indicating that there's more data. */
        if( remainingLength > 0U )
        {
            UINT8_SET_BIT( lengthByte, 7 );
        }

        /* Output a single encoded byte. */
        *pLengthEnd = lengthByte;
        pLengthEnd++;
    } while( remainingLength > 0U );

    return pLengthEnd;
}

/*-----------------------------------------------------------*/

static uint8_t * encodeString( uint8_t * pDestination,
                               const char * pSource,
                               uint16_t sourceLength )
{
    uint8_t * pBuffer = NULL;

    assert( pDestination != NULL );

    pBuffer = pDestination;

    /* The first byte of a UTF-8 string is the high byte of the string length. */
    *pBuffer = UINT16_HIGH_BYTE( sourceLength );
    pBuffer++;

    /* The second byte of a UTF-8 string is the low byte of the string length. */
    *pBuffer = UINT16_LOW_BYTE( sourceLength );
    pBuffer++;

    /* Copy the string into pBuffer. */
    if( pSource != NULL )
    {
        ( void ) memcpy( ( void * ) pBuffer, ( const void * ) pSource, sourceLength );
    }

    /* Return the pointer to the end of the encoded string. */
    pBuffer = &pBuffer[ sourceLength ];

    return pBuffer;
}

/*-----------------------------------------------------------*/

static bool calculatePublishPacketSize( const MQTTPublishInfo_t * pPublishInfo,
                                        size_t * pRemainingLength,
                                        size_t * pPacketSize )
{
    bool status = true;
    size_t packetSize = 0, payloadLimit = 0;

    assert( pPublishInfo != NULL );
    assert( pRemainingLength != NULL );
    assert( pPacketSize != NULL );

    /* The variable header of a PUBLISH packet always contains the topic name.
     * The first 2 bytes of UTF-8 string contains length of the string.
     */
    packetSize += pPublishInfo->topicNameLength + sizeof( uint16_t );

    /* The variable header of a QoS 1 or 2 PUBLISH packet contains a 2-byte
     * packet identifier. */
    if( pPublishInfo->qos > MQTTQoS0 )
    {
        packetSize += sizeof( uint16_t );
    }

    /* Calculate the maximum allowed size of the payload for the given parameters.
     * This calculation excludes the "Remaining length" encoding, whose size is not
     * yet known. */
    payloadLimit = MQTT_MAX_REMAINING_LENGTH - packetSize - 1U;

    /* Ensure that the given payload fits within the calculated limit. */
    if( pPublishInfo->payloadLength > payloadLimit )
    {
        LogError( ( "PUBLISH payload length of %lu cannot exceed "
                    "%lu so as not to exceed the maximum "
                    "remaining length of MQTT 3.1.1 packet( %lu ).",
                    ( unsigned long ) pPublishInfo->payloadLength,
                    ( unsigned long ) payloadLimit,
                    MQTT_MAX_REMAINING_LENGTH ) );
        status = false;
    }
    else
    {
        /* Add the length of the PUBLISH payload. At this point, the "Remaining length"
         * has been calculated. */
        packetSize += pPublishInfo->payloadLength;

        /* Now that the "Remaining length" is known, recalculate the payload limit
         * based on the size of its encoding. */
        payloadLimit -= remainingLengthEncodedSize( packetSize );

        /* Check that the given payload fits within the size allowed by MQTT spec. */
        if( pPublishInfo->payloadLength > payloadLimit )
        {
            LogError( ( "PUBLISH payload length of %lu cannot exceed "
                        "%lu so as not to exceed the maximum "
                        "remaining length of MQTT 3.1.1 packet( %lu ).",
                        ( unsigned long ) pPublishInfo->payloadLength,
                        ( unsigned long ) payloadLimit,
                        MQTT_MAX_REMAINING_LENGTH ) );
            status = false;
        }
        else
        {
            /* Set the "Remaining length" output parameter and calculate the full
             * size of the PUBLISH packet. */
            *pRemainingLength = packetSize;

            packetSize += 1U + remainingLengthEncodedSize( packetSize );
            *pPacketSize = packetSize;
        }
    }

    LogDebug( ( "PUBLISH packet remaining length=%lu and packet size=%lu.",
                ( unsigned long ) *pRemainingLength,
                ( unsigned long ) *pPacketSize ) );
    return status;
}

/*-----------------------------------------------------------*/

static size_t variableLengthEncodedSize( size_t length )
{
    size_t encodedSize;

    /* Determine how many bytes are needed to encode length.
     * The values below are taken from the MQTT 5.0 spec. */

    /* 1 byte is needed to encode lengths between 0 and 127. */
    if( length < 128U )
    {
        encodedSize = 1U;
    }
    /* 2 bytes are needed to encode lengths between 128 and 16,383. */
    else if( length < 16384U )
    {
        encodedSize = 2U;
    }
    /* 3 bytes are needed to encode lengths between 16,384 and 2,097,151. */
    else if( length < 2097152U )
    {
        encodedSize = 3U;
    }
    /* 4 bytes are needed to encode lengths between 2,097,152 and 268,435,455. */
    else
    {
        encodedSize = 4U;
    }

    LogDebug( ( "Encoded size for length %lu is %lu bytes.",
                ( unsigned long ) length,
                ( unsigned long ) encodedSize ) );

    return encodedSize;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_SerializePublishHeaderWithoutTopic( const MQTTPublishInfo_t * pPublishInfo,
                                                      size_t remainingLength,
                                                      uint8_t * pBuffer,
                                                      size_t * headerSize )
{
    size_t headerLength;
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    /* The first byte of a PUBLISH packet contains the packet type and flags. */
    uint8_t publishFlags = MQTT_PACKET_TYPE_PUBLISH;

    /* Get the start address of the buffer. */
    pIndex = pBuffer;

    /* Length of serialized packet = First byte
     *                               + Length of encoded remaining length
     *                               + Encoded topic length. */
    headerLength = 1U + remainingLengthEncodedSize( remainingLength ) + 2U;

    if( pPublishInfo->qos == MQTTQoS1 )
    {
        LogDebug( ( "Adding QoS as QoS1 in PUBLISH flags." ) );
        UINT8_SET_BIT( publishFlags, MQTT_PUBLISH_FLAG_QOS1 );
    }
    else if( pPublishInfo->qos == MQTTQoS2 )
    {
        LogDebug( ( "Adding QoS as QoS2 in PUBLISH flags." ) );
        UINT8_SET_BIT( publishFlags, MQTT_PUBLISH_FLAG_QOS2 );
    }
    else
    {
        /* Empty else MISRA 15.7 */
    }

    if( pPublishInfo->retain == true )
    {
        LogDebug( ( "Adding retain bit in PUBLISH flags." ) );
        UINT8_SET_BIT( publishFlags, MQTT_PUBLISH_FLAG_RETAIN );
    }

    if( pPublishInfo->dup == true )
    {
        LogDebug( ( "Adding dup bit in PUBLISH flags." ) );
        UINT8_SET_BIT( publishFlags, MQTT_PUBLISH_FLAG_DUP );
    }

    *pIndex = publishFlags;
    pIndex++;

    /* The "Remaining length" is encoded from the second byte. */
    pIndex = encodeRemainingLength( pIndex, remainingLength );

    /* The first byte of a UTF-8 string is the high byte of the string length. */
    *pIndex = UINT16_HIGH_BYTE( pPublishInfo->topicNameLength );
    pIndex++;

    /* The second byte of a UTF-8 string is the low byte of the string length. */
    *pIndex = UINT16_LOW_BYTE( pPublishInfo->topicNameLength );
    pIndex++;

    *headerSize = headerLength;

    return status;
}

/*-----------------------------------------------------------*/

static void serializePublishCommon( const MQTTPublishInfo_t * pPublishInfo,
                                    size_t remainingLength,
                                    uint16_t packetIdentifier,
                                    const MQTTFixedBuffer_t * pFixedBuffer,
                                    bool serializePayload )
{
    uint8_t * pIndex = NULL;

    /* The first byte of a PUBLISH packet contains the packet type and flags. */
    uint8_t publishFlags = MQTT_PACKET_TYPE_PUBLISH;

    assert( pPublishInfo != NULL );
    assert( pFixedBuffer != NULL );
    assert( pFixedBuffer->pBuffer != NULL );
    /* Packet Id should be non zero for Qos 1 and Qos 2. */
    assert( ( pPublishInfo->qos == MQTTQoS0 ) || ( packetIdentifier != 0U ) );
    /* Duplicate flag should be set only for Qos 1 or Qos 2. */
    assert( ( pPublishInfo->dup != true ) || ( pPublishInfo->qos != MQTTQoS0 ) );

    /* Get the start address of the buffer. */
    pIndex = pFixedBuffer->pBuffer;

    if( pPublishInfo->qos == MQTTQoS1 )
    {
        LogDebug( ( "Adding QoS as QoS1 in PUBLISH flags." ) );
        UINT8_SET_BIT( publishFlags, MQTT_PUBLISH_FLAG_QOS1 );
    }
    else if( pPublishInfo->qos == MQTTQoS2 )
    {
        LogDebug( ( "Adding QoS as QoS2 in PUBLISH flags." ) );
        UINT8_SET_BIT( publishFlags, MQTT_PUBLISH_FLAG_QOS2 );
    }
    else
    {
        /* Empty else MISRA 15.7 */
    }

    if( pPublishInfo->retain == true )
    {
        LogDebug( ( "Adding retain bit in PUBLISH flags." ) );
        UINT8_SET_BIT( publishFlags, MQTT_PUBLISH_FLAG_RETAIN );
    }

    if( pPublishInfo->dup == true )
    {
        LogDebug( ( "Adding dup bit in PUBLISH flags." ) );
        UINT8_SET_BIT( publishFlags, MQTT_PUBLISH_FLAG_DUP );
    }

    *pIndex = publishFlags;
    pIndex++;

    /* The "Remaining length" is encoded from the second byte. */
    pIndex = encodeRemainingLength( pIndex, remainingLength );

    /* The topic name is placed after the "Remaining length". */
    pIndex = encodeString( pIndex,
                           pPublishInfo->pTopicName,
                           pPublishInfo->topicNameLength );

    /* A packet identifier is required for QoS 1 and 2 messages. */
    if( pPublishInfo->qos > MQTTQoS0 )
    {
        LogDebug( ( "Adding packet Id in PUBLISH packet." ) );
        /* Place the packet identifier into the PUBLISH packet. */
        *pIndex = UINT16_HIGH_BYTE( packetIdentifier );
        pIndex[ 1U ] = UINT16_LOW_BYTE( packetIdentifier );
        pIndex = &pIndex[ 2U ];
    }

    /* The payload is placed after the packet identifier.
     * Payload is copied over only if required by the flag serializePayload.
     * This will help reduce an unnecessary copy of the payload into the buffer.
     */
    if( ( pPublishInfo->payloadLength > 0U ) &&
        ( serializePayload == true ) )
    {
        LogDebug( ( "Copying PUBLISH payload of length =%lu to buffer",
                    ( unsigned long ) pPublishInfo->payloadLength ) );

        ( void ) memcpy( ( void * ) pIndex, ( const void * ) pPublishInfo->pPayload, pPublishInfo->payloadLength );
        /* Move the index to after the payload. */
        pIndex = &pIndex[ pPublishInfo->payloadLength ];
    }

    /* Ensure that the difference between the end and beginning of the buffer
     * is less than the buffer size. */
    assert( ( ( size_t ) ( pIndex - pFixedBuffer->pBuffer ) ) <= pFixedBuffer->size );
}

static size_t getRemainingLength( TransportRecv_t recvFunc,
                                  NetworkContext_t * pNetworkContext )
{
    size_t remainingLength = 0, multiplier = 1, bytesDecoded = 0, expectedSize = 0;
    uint8_t encodedByte = 0;
    int32_t bytesReceived = 0;

    /* This algorithm is copied from the MQTT v3.1.1 spec. */
    do
    {
        if( multiplier > 2097152U ) /* 128 ^ 3 */
        {
            remainingLength = MQTT_REMAINING_LENGTH_INVALID;
        }
        else
        {
            bytesReceived = recvFunc( pNetworkContext, &encodedByte, 1U );

            if( bytesReceived == 1 )
            {
                remainingLength += ( ( size_t ) encodedByte & 0x7FU ) * multiplier;
                multiplier *= 128U;
                bytesDecoded++;
            }
            else
            {
                remainingLength = MQTT_REMAINING_LENGTH_INVALID;
            }
        }

        if( remainingLength == MQTT_REMAINING_LENGTH_INVALID )
        {
            break;
        }
    } while( ( encodedByte & 0x80U ) != 0U );

    /* Check that the decoded remaining length conforms to the MQTT specification. */
    if( remainingLength != MQTT_REMAINING_LENGTH_INVALID )
    {
        expectedSize = remainingLengthEncodedSize( remainingLength );

        if( bytesDecoded != expectedSize )
        {
            remainingLength = MQTT_REMAINING_LENGTH_INVALID;
        }
    }

    return remainingLength;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t processRemainingLength( const uint8_t * pBuffer,
                                            const size_t * pIndex,
                                            MQTTPacketInfo_t * pIncomingPacket )
{
    size_t remainingLength = 0;
    size_t multiplier = 1;
    size_t bytesDecoded = 0;
    size_t expectedSize = 0;
    uint8_t encodedByte = 0;
    MQTTStatus_t status = MQTTSuccess;

    /* This algorithm is copied from the MQTT v3.1.1 spec. */
    do
    {
        if( multiplier > 2097152U ) /* 128 ^ 3 */
        {
            remainingLength = MQTT_REMAINING_LENGTH_INVALID;

            LogError( ( "Invalid remaining length in the packet.\n" ) );

            status = MQTTBadResponse;
        }
        else
        {
            if( *pIndex > ( bytesDecoded + 1U ) )
            {
                /* Get the next byte. It is at the next position after the bytes
                 * decoded till now since the header of one byte was read before. */
                encodedByte = pBuffer[ bytesDecoded + 1U ];

                remainingLength += ( ( size_t ) encodedByte & 0x7FU ) * multiplier;
                multiplier *= 128U;
                bytesDecoded++;
            }
            else
            {
                status = MQTTNeedMoreBytes;
            }
        }

        /* If the response is incorrect, or no more data is available, then
         * break out of the loop. */
        if( ( remainingLength == MQTT_REMAINING_LENGTH_INVALID ) ||
            ( status != MQTTSuccess ) )
        {
            break;
        }
    } while( ( encodedByte & 0x80U ) != 0U );

    if( status == MQTTSuccess )
    {
        /* Check that the decoded remaining length conforms to the MQTT specification. */
        expectedSize = remainingLengthEncodedSize( remainingLength );

        if( bytesDecoded != expectedSize )
        {
            LogError( ( "Expected and actual length of decoded bytes do not match.\n" ) );
            status = MQTTBadResponse;
        }
        else
        {
            pIncomingPacket->remainingLength = remainingLength;
            pIncomingPacket->headerLength = bytesDecoded + 1U;
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

static bool incomingPacketValid( uint8_t packetType )
{
    bool status = false;

    /* Check packet type. Mask out lower bits to ignore flags. */
    switch( packetType & 0xF0U )
    {
        /* Valid incoming packet types. */
        case MQTT_PACKET_TYPE_CONNACK:
        case MQTT_PACKET_TYPE_PUBLISH:
        case MQTT_PACKET_TYPE_PUBACK:
        case MQTT_PACKET_TYPE_PUBREC:
        case MQTT_PACKET_TYPE_PUBCOMP:
        case MQTT_PACKET_TYPE_SUBACK:
        case MQTT_PACKET_TYPE_UNSUBACK:
        case MQTT_PACKET_TYPE_PINGRESP:
            status = true;
            break;

        case ( MQTT_PACKET_TYPE_PUBREL & 0xF0U ):

            /* The second bit of a PUBREL must be set. */
            if( ( packetType & 0x02U ) > 0U )
            {
                status = true;
            }

            break;

        /* Any other packet type is invalid. */
        default:
            LogWarn( ( "Incoming packet invalid: Packet type=%u.",
                       ( unsigned int ) packetType ) );
            break;
    }

    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t checkPublishRemainingLength( size_t remainingLength,
                                                 MQTTQoS_t qos,
                                                 size_t qos0Minimum )
{
    MQTTStatus_t status = MQTTSuccess;

    /* Sanity checks for "Remaining length". */
    if( qos == MQTTQoS0 )
    {
        /* Check that the "Remaining length" is greater than the minimum. */
        if( remainingLength < qos0Minimum )
        {
            LogError( ( "QoS 0 PUBLISH cannot have a remaining length less than %lu.",
                        ( unsigned long ) qos0Minimum ) );

            status = MQTTBadResponse;
        }
    }
    else
    {
        /* Check that the "Remaining length" is greater than the minimum. For
         * QoS 1 or 2, this will be two bytes greater than for QoS 0 due to the
         * packet identifier. */
        if( remainingLength < ( qos0Minimum + 2U ) )
        {
            LogError( ( "QoS 1 or 2 PUBLISH cannot have a remaining length less than %lu.",
                        ( unsigned long ) ( qos0Minimum + 2U ) ) );

            status = MQTTBadResponse;
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t processPublishFlags( uint8_t publishFlags,
                                         MQTTPublishInfo_t * pPublishInfo )
{
    MQTTStatus_t status = MQTTSuccess;

    assert( pPublishInfo != NULL );

    /* Check for QoS 2. */
    if( UINT8_CHECK_BIT( publishFlags, MQTT_PUBLISH_FLAG_QOS2 ) )
    {
        /* PUBLISH packet is invalid if both QoS 1 and QoS 2 bits are set. */
        if( UINT8_CHECK_BIT( publishFlags, MQTT_PUBLISH_FLAG_QOS1 ) )
        {
            LogError( ( "Bad QoS: 3." ) );

            status = MQTTBadResponse;
        }
        else
        {
            pPublishInfo->qos = MQTTQoS2;
        }
    }
    /* Check for QoS 1. */
    else if( UINT8_CHECK_BIT( publishFlags, MQTT_PUBLISH_FLAG_QOS1 ) )
    {
        pPublishInfo->qos = MQTTQoS1;
    }
    /* If the PUBLISH isn't QoS 1 or 2, then it's QoS 0. */
    else
    {
        pPublishInfo->qos = MQTTQoS0;
    }

    if( status == MQTTSuccess )
    {
        LogDebug( ( "QoS is %d.", ( int ) pPublishInfo->qos ) );

        /* Parse the Retain bit. */
        pPublishInfo->retain = UINT8_CHECK_BIT( publishFlags, MQTT_PUBLISH_FLAG_RETAIN );

        LogDebug( ( "Retain bit is %d.", ( int ) pPublishInfo->retain ) );

        /* Parse the DUP bit. */
        pPublishInfo->dup = UINT8_CHECK_BIT( publishFlags, MQTT_PUBLISH_FLAG_DUP );

        LogDebug( ( "DUP bit is %d.", ( int ) pPublishInfo->dup ) );
    }

    return status;
}

/*-----------------------------------------------------------*/

static void logConnackResponse( uint8_t responseCode )
{
    /* Log an error based on the CONNACK response code. */
    switch( responseCode )
    {
        case ( uint8_t ) MQTT_REASON_CONNACK_SUCCESS:
            LogDebug( ( "Connection accepted." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_UNSPECIFIED_ERROR:
            LogError( ( "Connection refused: Unspecified error" ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_MALFORMED_PACKET:
            LogError( ( "Connection refused: Malformed Packet." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_PROTOCOL_ERROR:
            LogError( ( "Connection refused: Protocol Error." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_IMPLEMENTATION_SPECIFIC_ERROR:
            LogError( ( "Connection refused: Implementation specific error." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_UNSUPPORTED_PROTOCOL_VERSION:
            LogError( ( "Connection refused: Unsupported Protocol Version." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_CLIENT_IDENTIFIER_NOT_VALID:
            LogError( ( "Connection refused: Client Identifier not valid." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_BAD_USER_NAME_OR_PASSWORD:
            LogError( ( "Connection refused: Bad User Name or Password." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_NOT_AUTHORIZED:
            LogError( ( "Connection refused: Not authorized." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_SERVER_UNAVAILABLE:
            LogError( ( "Connection refused: Server unavailable." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_SERVER_BUSY:
            LogError( ( "Connection refused: Server busy." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_BANNED:
            LogError( ( "Connection refused: Banned." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_BAD_AUTHENTICATION_METHOD:
            LogError( ( "Connection refused: Bad authentication method." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_TOPIC_NAME_INVALID:
            LogError( ( "Connection refused: Topic Name invalid." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_PACKET_TOO_LARGE:
            LogError( ( "Connection refused: Packet too large ." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_QUOTA_EXCEEDED:
            LogError( ( "Connection refused: Quota exceeded." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_PAYLOAD_FORMAT_INVALID:
            LogError( ( "Connection refused: Payload format invalid." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_RETAIN_NOT_SUPPORTED:
            LogError( ( "Connection refused: Retain not supported." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_QOS_NOT_SUPPORTED:
            LogError( ( "Connection refused: QoS not supported." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_USE_ANOTHER_SERVER:
            LogError( ( "Connection refused: Use another server." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_SERVER_MOVED:
            LogError( ( "Connection refused: Server moved." ) );
            break;

        case ( uint8_t ) MQTT_REASON_CONNACK_CONNECTION_RATE_EXCEEDED:
            LogError( ( "Connection refused: Connection rate exceeded." ) );
            break;

        default:
            LogError( ( "Invalid reason code received." ) );
            assert( false );
            break;
    }
}

/*-----------------------------------------------------------*/

static inline MQTTStatus_t isValidConnackReasonCode( uint8_t reasonCode )
{
    MQTTStatus_t status;

    switch( reasonCode )
    {
        case ( uint8_t ) MQTT_REASON_CONNACK_SUCCESS:
        case ( uint8_t ) MQTT_REASON_CONNACK_UNSPECIFIED_ERROR:
        case ( uint8_t ) MQTT_REASON_CONNACK_MALFORMED_PACKET:
        case ( uint8_t ) MQTT_REASON_CONNACK_PROTOCOL_ERROR:
        case ( uint8_t ) MQTT_REASON_CONNACK_IMPLEMENTATION_SPECIFIC_ERROR:
        case ( uint8_t ) MQTT_REASON_CONNACK_UNSUPPORTED_PROTOCOL_VERSION:
        case ( uint8_t ) MQTT_REASON_CONNACK_CLIENT_IDENTIFIER_NOT_VALID:
        case ( uint8_t ) MQTT_REASON_CONNACK_BAD_USER_NAME_OR_PASSWORD:
        case ( uint8_t ) MQTT_REASON_CONNACK_NOT_AUTHORIZED:
        case ( uint8_t ) MQTT_REASON_CONNACK_SERVER_UNAVAILABLE:
        case ( uint8_t ) MQTT_REASON_CONNACK_SERVER_BUSY:
        case ( uint8_t ) MQTT_REASON_CONNACK_BANNED:
        case ( uint8_t ) MQTT_REASON_CONNACK_BAD_AUTHENTICATION_METHOD:
        case ( uint8_t ) MQTT_REASON_CONNACK_TOPIC_NAME_INVALID:
        case ( uint8_t ) MQTT_REASON_CONNACK_PACKET_TOO_LARGE:
        case ( uint8_t ) MQTT_REASON_CONNACK_QUOTA_EXCEEDED:
        case ( uint8_t ) MQTT_REASON_CONNACK_PAYLOAD_FORMAT_INVALID:
        case ( uint8_t ) MQTT_REASON_CONNACK_RETAIN_NOT_SUPPORTED:
        case ( uint8_t ) MQTT_REASON_CONNACK_QOS_NOT_SUPPORTED:
        case ( uint8_t ) MQTT_REASON_CONNACK_USE_ANOTHER_SERVER:
        case ( uint8_t ) MQTT_REASON_CONNACK_SERVER_MOVED:
        case ( uint8_t ) MQTT_REASON_CONNACK_CONNECTION_RATE_EXCEEDED:
            status = MQTTSuccess;
            break;
        default:
            LogError( ( "Invalid reason code received." ) );
            status = MQTTBadResponse;
            break;
    }

    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t validateConnackParams( const MQTTPacketInfo_t * pIncomingPacket,
                                           bool * pSessionPresent )
{
    MQTTStatus_t status = MQTTSuccess;
    const uint8_t * pRemainingData;
    uint8_t reasonCode;

    assert( pIncomingPacket != NULL );
    assert( pSessionPresent != NULL );
    assert( pIncomingPacket->pRemainingData != NULL );
    assert( pIncomingPacket->type == MQTT_PACKET_TYPE_CONNACK );

    /* Remaining Length of the CONNACK cannot be less than 3.
     * 1 byte for each of the following:
     * - Connect Acknowledge Flags
     * - Connect Reason Code
     * - Properties (0x00) indicating no trailing properties. */
    if( pIncomingPacket->remainingLength < MQTT_PACKET_CONNACK_MINIMUM_SIZE )
    {
        LogError( ( "Incomplete Connack received" ) );

        status = MQTTBadResponse;
    }

    if( status == MQTTSuccess )
    {
        pRemainingData = pIncomingPacket->pRemainingData;
        reasonCode = pRemainingData[ 1 ];

        /* Reserved bits in CONNACK must be 0. */
        if( ( pRemainingData[ 0 ] | 0x01U ) != 0x01U )
        {
            LogError( ( "Reserved bits in CONNACK not set to 0." ) );

            status = MQTTBadResponse;
        }
        else
        {
            /* Determine if the "Session Present" bit is set. This is the
             * lowest bit of the first byte of variable header. */
            if( ( pRemainingData[ 0 ] & MQTT_PACKET_CONNACK_SESSION_PRESENT_MASK ) ==
                MQTT_PACKET_CONNACK_SESSION_PRESENT_MASK )
            {
                LogDebug( ( "CONNACK session present bit set." ) );
                *pSessionPresent = true;

                /* MQTT 5 specifies that the fourth byte in CONNACK must be 0 if the
                 * "Session Present" bit is set. */
                if( reasonCode != 0U )
                {
                    LogError( ( "Session Present bit is set, but connect return code in CONNACK is %u (nonzero).",
                                ( unsigned int ) reasonCode ) );
                    status = MQTTBadResponse;
                }
            }
            else
            {
                LogDebug( ( "CONNACK session present bit not set." ) );
                *pSessionPresent = false;
            }
        }
    }

    if( status == MQTTSuccess )
    {
        if( isValidConnackReasonCode( reasonCode ) != MQTTSuccess )
        {
            status = MQTTBadResponse;
        }
        else
        {
            if( reasonCode != MQTT_REASON_CONNACK_SUCCESS )
            {
                status = MQTTServerRefused;
            }

            logConnackResponse( reasonCode );
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t deserializeConnack( MQTTConnectionProperties_t * pConnackProperties,
                                 const MQTTPacketInfo_t * pIncomingPacket,
                                 bool * pSessionPresent,
                                 MQTTPropBuilder_t * pPropBuffer )
{
    MQTTStatus_t status = MQTTSuccess;
    size_t propertyLength = 0U;
    uint8_t * pVariableHeader = NULL;
    MQTTStatus_t statusCopy = MQTTSuccess;

    /* Validate the arguments. */
    status = validateConnackParams( pIncomingPacket, pSessionPresent );

    if( status == MQTTServerRefused )
    {
        statusCopy = status;
    }

    if( ( status == MQTTSuccess ) || ( status == MQTTServerRefused ) )
    {
        pVariableHeader = pIncomingPacket->pRemainingData;

        /* Skip over flags and reason code. */
        pVariableHeader = &pVariableHeader[ 2U ];
        status = decodeVariableLength( pVariableHeader, pIncomingPacket->remainingLength - 2U, &propertyLength );
    }

    /* Validate the packet size if max packet size is set. */
    if( status == MQTTSuccess )
    {
        /* Validate the remaining length. */
        if( ( pIncomingPacket->remainingLength ) != ( 2U + propertyLength + variableLengthEncodedSize( propertyLength ) ) )
        {
            LogError( ( "Invalid Remaining Length" ) );
            status = MQTTBadResponse;
        }
        /* Deserialize the connack properties. */
        else
        {
            status = deserializeConnackProperties( pConnackProperties, propertyLength, pVariableHeader, pPropBuffer );
        }
    }

    if( status == MQTTSuccess )
    {
        status = statusCopy;
    }

    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t calculateSubscriptionPacketSize( const MQTTSubscribeInfo_t * pSubscriptionList,
                                                     size_t subscriptionCount,
                                                     size_t * pRemainingLength,
                                                     size_t * pPacketSize,
                                                     MQTTSubscriptionType_t subscriptionType )
{
    MQTTStatus_t status = MQTTSuccess;
    size_t i = 0, packetSize = 0;

    assert( pSubscriptionList != NULL );
    assert( subscriptionCount != 0U );
    assert( pRemainingLength != NULL );
    assert( pPacketSize != NULL );

    /* The variable header of a subscription packet consists of a 2-byte packet
     * identifier. */
    packetSize += sizeof( uint16_t );

    /* Sum the lengths of all subscription topic filters; add 1 byte for each
     * subscription's QoS if type is MQTT_SUBSCRIBE. */
    for( i = 0; i < subscriptionCount; i++ )
    {
        /* Add the length of the topic filter. MQTT strings are prepended
         * with 2 byte string length field. Hence 2 bytes are added to size. */
        packetSize += pSubscriptionList[ i ].topicFilterLength + sizeof( uint16_t );

        /* Only SUBSCRIBE packets include the QoS. */
        if( subscriptionType == MQTT_SUBSCRIBE )
        {
            packetSize += 1U;
        }

        /* Validate each topic filter. */
        if( ( pSubscriptionList[ i ].topicFilterLength == 0U ) ||
            ( pSubscriptionList[ i ].pTopicFilter == NULL ) )
        {
            status = MQTTBadParameter;
            LogError( ( "Subscription #%lu in %sSUBSCRIBE packet cannot be empty.",
                        ( unsigned long ) i,
                        ( subscriptionType == MQTT_SUBSCRIBE ) ? "" : "UN" ) );
            /* It is not necessary to break as an error status has already been set. */
        }
    }

    /* At this point, the "Remaining length" has been calculated. Return error
     * if the "Remaining length" exceeds what is allowed by MQTT 3.1.1. Otherwise,
     * set the output parameter.*/
    if( packetSize > MQTT_MAX_REMAINING_LENGTH )
    {
        LogError( ( "Subscription packet length of %lu exceeds"
                    "the MQTT 3.1.1 maximum packet length of %lu.",
                    ( unsigned long ) packetSize,
                    MQTT_MAX_REMAINING_LENGTH ) );
        status = MQTTBadParameter;
    }

    if( status == MQTTSuccess )
    {
        *pRemainingLength = packetSize;

        /* Calculate the full size of the subscription packet by adding
         * number of bytes required to encode the "Remaining length" field
         * plus 1 byte for the "Packet type" field. */
        packetSize += 1U + remainingLengthEncodedSize( packetSize );

        /* Set the pPacketSize output parameter. */
        *pPacketSize = packetSize;
    }

    LogDebug( ( "Subscription packet remaining length=%lu and packet size=%lu.",
                ( unsigned long ) *pRemainingLength,
                ( unsigned long ) *pPacketSize ) );

    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t readSubackStatus( size_t statusCount,
                                      const uint8_t * pStatusStart )
{
    MQTTStatus_t status = MQTTSuccess;
    uint8_t subscriptionStatus = 0;
    size_t i = 0;

    assert( pStatusStart != NULL );

    /* Iterate through each status byte in the SUBACK packet. */
    for( i = 0; i < statusCount; i++ )
    {
        /* Read a single status byte in SUBACK. */
        subscriptionStatus = pStatusStart[ i ];

        /* MQTT 3.1.1 defines the following values as status codes. */
        switch( subscriptionStatus )
        {
            case 0x00:
            case 0x01:
            case 0x02:

                LogDebug( ( "Topic filter %lu accepted, max QoS %u.",
                            ( unsigned long ) i,
                            ( unsigned int ) subscriptionStatus ) );
                break;

            case 0x80:

                LogWarn( ( "Topic filter %lu refused.", ( unsigned long ) i ) );

                /* Application should remove subscription from the list */
                status = MQTTServerRefused;

                break;

            default:
                LogError( ( "Bad SUBSCRIBE status %u.",
                            ( unsigned int ) subscriptionStatus ) );

                status = MQTTBadResponse;

                break;
        }

        /* Stop parsing the subscription statuses if a bad response was received. */
        if( status == MQTTBadResponse )
        {
            break;
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t deserializeSuback( const MQTTPacketInfo_t * pSuback,
                                       uint16_t * pPacketIdentifier )
{
    MQTTStatus_t status = MQTTSuccess;
    size_t remainingLength;
    const uint8_t * pVariableHeader = NULL;

    assert( pSuback != NULL );
    assert( pPacketIdentifier != NULL );

    remainingLength = pSuback->remainingLength;
    pVariableHeader = pSuback->pRemainingData;

    /* A SUBACK must have a remaining length of at least 3 to accommodate the
     * packet identifier and at least 1 return code. */
    if( remainingLength < 3U )
    {
        LogError( ( "SUBACK cannot have a remaining length less than 3." ) );
        status = MQTTBadResponse;
    }
    else
    {
        /* Extract the packet identifier (first 2 bytes of variable header) from SUBACK. */
        *pPacketIdentifier = UINT16_DECODE( pVariableHeader );

        LogDebug( ( "Packet identifier %hu.",
                    ( unsigned short ) *pPacketIdentifier ) );

        if( *pPacketIdentifier == 0U )
        {
            status = MQTTBadResponse;
        }
        else
        {
            status = readSubackStatus( remainingLength - sizeof( uint16_t ),
                                       &pVariableHeader[ sizeof( uint16_t ) ] );
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t validateSubscriptionSerializeParams( const MQTTSubscribeInfo_t * pSubscriptionList,
                                                         size_t subscriptionCount,
                                                         uint16_t packetId,
                                                         size_t remainingLength,
                                                         const MQTTFixedBuffer_t * pFixedBuffer )
{
    MQTTStatus_t status = MQTTSuccess;
    size_t packetSize = 0;

    /* Validate all the parameters. */
    if( ( pFixedBuffer == NULL ) || ( pSubscriptionList == NULL ) )
    {
        LogError( ( "Argument cannot be NULL: pFixedBuffer=%p, "
                    "pSubscriptionList=%p.",
                    ( void * ) pFixedBuffer,
                    ( void * ) pSubscriptionList ) );
        status = MQTTBadParameter;
    }
    /* A buffer must be configured for serialization. */
    else if( pFixedBuffer->pBuffer == NULL )
    {
        LogError( ( "Argument cannot be NULL: pFixedBuffer->pBuffer is NULL." ) );
        status = MQTTBadParameter;
    }
    else if( subscriptionCount == 0U )
    {
        LogError( ( "Subscription count is 0." ) );
        status = MQTTBadParameter;
    }
    else if( packetId == 0U )
    {
        LogError( ( "Packet Id for subscription packet is 0." ) );
        status = MQTTBadParameter;
    }
    else
    {
        /* The serialized packet size = First byte
         * + length of encoded size of remaining length
         * + remaining length. */
        packetSize = 1U + remainingLengthEncodedSize( remainingLength )
                     + remainingLength;

        if( packetSize > pFixedBuffer->size )
        {
            LogError( ( "Buffer size of %lu is not sufficient to hold "
                        "serialized packet of size of %lu.",
                        ( unsigned long ) pFixedBuffer->size,
                        ( unsigned long ) packetSize ) );
            status = MQTTNoMemory;
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t deserializePublish( const MQTTPacketInfo_t * pIncomingPacket,
                                        uint16_t * pPacketId,
                                        MQTTPublishInfo_t * pPublishInfo )
{
    MQTTStatus_t status = MQTTSuccess;
    const uint8_t * pVariableHeader, * pPacketIdentifierHigh = NULL;

    assert( pIncomingPacket != NULL );
    assert( pPacketId != NULL );
    assert( pPublishInfo != NULL );
    assert( pIncomingPacket->pRemainingData != NULL );

    pVariableHeader = pIncomingPacket->pRemainingData;
    /* The flags are the lower 4 bits of the first byte in PUBLISH. */
    status = processPublishFlags( ( pIncomingPacket->type & 0x0FU ), pPublishInfo );

    if( status == MQTTSuccess )
    {
        /* Sanity checks for "Remaining length". A QoS 0 PUBLISH  must have a remaining
         * length of at least 3 to accommodate topic name length (2 bytes) and topic
         * name (at least 1 byte). A QoS 1 or 2 PUBLISH must have a remaining length of
         * at least 5 for the packet identifier in addition to the topic name length and
         * topic name. */
        status = checkPublishRemainingLength( pIncomingPacket->remainingLength,
                                              pPublishInfo->qos,
                                              MQTT_MIN_PUBLISH_REMAINING_LENGTH_QOS0 );
    }

    if( status == MQTTSuccess )
    {
        /* Extract the topic name starting from the first byte of the variable header.
         * The topic name string starts at byte 3 in the variable header. */
        pPublishInfo->topicNameLength = UINT16_DECODE( pVariableHeader );

        /* Sanity checks for topic name length and "Remaining length". The remaining
         * length must be at least as large as the variable length header. */
        status = checkPublishRemainingLength( pIncomingPacket->remainingLength,
                                              pPublishInfo->qos,
                                              pPublishInfo->topicNameLength + sizeof( uint16_t ) );
    }

    if( status == MQTTSuccess )
    {
        /* Parse the topic. */
        pPublishInfo->pTopicName = ( const char * ) ( &pVariableHeader[ sizeof( uint16_t ) ] );
        LogDebug( ( "Topic name length: %hu.", ( unsigned short ) pPublishInfo->topicNameLength ) );

        /* Extract the packet identifier for QoS 1 or 2 PUBLISH packets. Packet
         * identifier starts immediately after the topic name. */
        /* coverity[tainted_scalar] */
        pPacketIdentifierHigh = ( const uint8_t * ) ( &pPublishInfo->pTopicName[ pPublishInfo->topicNameLength ] );

        if( pPublishInfo->qos > MQTTQoS0 )
        {
            *pPacketId = UINT16_DECODE( pPacketIdentifierHigh );

            LogDebug( ( "Packet identifier %hu.",
                        ( unsigned short ) *pPacketId ) );

            /* Advance pointer two bytes to start of payload as in the QoS 0 case. */
            pPacketIdentifierHigh = &pPacketIdentifierHigh[ sizeof( uint16_t ) ];

            /* Packet identifier cannot be 0. */
            if( *pPacketId == 0U )
            {
                LogError( ( "Packet identifier cannot be 0." ) );
                status = MQTTBadResponse;
            }
        }
    }

    if( status == MQTTSuccess )
    {
        /* Calculate the length of the payload. QoS 1 or 2 PUBLISH packets contain
         * a packet identifier, but QoS 0 PUBLISH packets do not. */
        pPublishInfo->payloadLength = pIncomingPacket->remainingLength - pPublishInfo->topicNameLength - sizeof( uint16_t );

        if( pPublishInfo->qos != MQTTQoS0 )
        {
            /* Two more bytes for the packet identifier. */
            pPublishInfo->payloadLength -= sizeof( uint16_t );
        }

        /* Set payload if it exists. */
        pPublishInfo->pPayload = ( pPublishInfo->payloadLength != 0U ) ? pPacketIdentifierHigh : NULL;

        LogDebug( ( "Payload length %lu.",
                    ( unsigned long ) pPublishInfo->payloadLength ) );
    }

    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t deserializeSimpleAck( const MQTTPacketInfo_t * pAck,
                                          uint16_t * pPacketIdentifier )
{
    MQTTStatus_t status = MQTTSuccess;

    assert( pAck != NULL );
    assert( pPacketIdentifier != NULL );

    /* Check that the "Remaining length" of the received ACK is 2. */
    if( pAck->remainingLength != MQTT_PACKET_SIMPLE_ACK_REMAINING_LENGTH )
    {
        LogError( ( "ACK does not have remaining length of %u.",
                    ( unsigned int ) MQTT_PACKET_SIMPLE_ACK_REMAINING_LENGTH ) );

        status = MQTTBadResponse;
    }
    else
    {
        /* Extract the packet identifier (third and fourth bytes) from ACK. */
        *pPacketIdentifier = UINT16_DECODE( pAck->pRemainingData );

        LogDebug( ( "Packet identifier %hu.",
                    ( unsigned short ) *pPacketIdentifier ) );

        /* Packet identifier cannot be 0. */
        if( *pPacketIdentifier == 0U )
        {
            LogError( ( "Packet identifier cannot be 0." ) );
            status = MQTTBadResponse;
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t deserializePingresp( const MQTTPacketInfo_t * pPingresp )
{
    MQTTStatus_t status = MQTTSuccess;

    assert( pPingresp != NULL );

    /* Check the "Remaining length" (second byte) of the received PINGRESP is 0. */
    if( pPingresp->remainingLength != MQTT_PACKET_PINGRESP_REMAINING_LENGTH )
    {
        LogError( ( "PINGRESP does not have remaining length of %u.",
                    MQTT_PACKET_PINGRESP_REMAINING_LENGTH ) );

        status = MQTTBadResponse;
    }

    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t decodeVariableLength( const uint8_t * pBuffer,
                                          size_t bufferLength,
                                          size_t * pLength )
{
    size_t remainingLength = 0;
    size_t multiplier = 1;
    size_t bytesDecoded = 0;
    size_t expectedSize = 0;
    uint8_t encodedByte = 0;
    size_t localBufferLength = bufferLength;
    MQTTStatus_t status = MQTTSuccess;

    /* This algorithm is copied from the MQTT 5.0 spec. */
    do
    {
        if( multiplier > 2097152U ) /* 128 ^ 3 */
        {
            remainingLength = MQTT_REMAINING_LENGTH_INVALID;

            LogError( ( "Invalid remaining length in the packet.\n" ) );

            status = MQTTBadResponse;
        }
        else
        {
            if( localBufferLength > 0U )
            {
                encodedByte = pBuffer[ bytesDecoded ];
                remainingLength += ( ( size_t ) encodedByte & 0x7FU ) * multiplier;
                multiplier *= 128U;
                bytesDecoded++;
                localBufferLength--;
            }
            else
            {
                status = MQTTBadResponse;
            }
        }

        /* If the response is incorrect then
         * break out of the loop. */
        if( ( remainingLength == MQTT_REMAINING_LENGTH_INVALID ) ||
            ( status != MQTTSuccess ) )
        {
            break;
        }
    } while( ( encodedByte & 0x80U ) != 0U );

    if( status == MQTTSuccess )
    {
        /* Check that the decoded remaining length conforms to the MQTT specification. */
        expectedSize = variableLengthEncodedSize( remainingLength );

        if( bytesDecoded != expectedSize )
        {
            LogError( ( "Expected and actual length of decoded bytes do not match.\n" ) );
            status = MQTTBadResponse;
        }
        else
        {
            *pLength = remainingLength;
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t decodeUint32t( uint32_t * pProperty,
                                    size_t * pPropertyLength,
                                    bool * pUsed,
                                    uint8_t ** pIndex )
{
    uint8_t * pLocalIndex = *pIndex;
    MQTTStatus_t status = MQTTSuccess;

    /* Protocol error to include the same property twice. */
    if( *pUsed == true )
    {
        status = MQTTBadResponse;
    }
    /* Validate the length and decode. */
    else if( *pPropertyLength < sizeof( uint32_t ) )
    {
        status = MQTTBadResponse;
    }
    else
    {
        if( pProperty != NULL )
        {
            *pProperty = UINT32_DECODE( pLocalIndex );
        }
        pLocalIndex = &pLocalIndex[ sizeof( uint32_t ) ];
        *pUsed = true;
        *pPropertyLength -= sizeof( uint32_t );
    }

    *pIndex = pLocalIndex;
    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t decodeUint16t( uint16_t * pProperty,
                                    size_t * pPropertyLength,
                                    bool * pUsed,
                                    uint8_t ** pIndex )
{
    uint8_t * pLocalIndex = *pIndex;
    MQTTStatus_t status = MQTTSuccess;

    /* Protocol error to include the same property twice. */

    if( *pUsed == true )
    {
        status = MQTTBadResponse;
    }
    /* Validate the length and decode. */

    else if( *pPropertyLength < sizeof( uint16_t ) )
    {
        status = MQTTBadResponse;
    }
    else
    {
        if( pProperty != NULL )
        {
            *pProperty = UINT16_DECODE( pLocalIndex );
        }
        pLocalIndex = &pLocalIndex[ sizeof( uint16_t ) ];
        *pUsed = true;
        *pPropertyLength -= sizeof( uint16_t );
    }

    *pIndex = pLocalIndex;
    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t decodeUint8t( uint8_t * pProperty,
                                   size_t * pPropertyLength,
                                   bool * pUsed,
                                   uint8_t ** pIndex )
{
    uint8_t * pLocalIndex = *pIndex;
    MQTTStatus_t status = MQTTSuccess;

    /* Protocol error to include the same property twice. */

    if( *pUsed == true )
    {
        status = MQTTBadResponse;
    }
    /* Validate the length and decode. */

    else if( *pPropertyLength < sizeof( uint8_t ) )
    {
        status = MQTTBadResponse;
    }
    else
    {
        *pProperty = *pLocalIndex;
        pLocalIndex = &pLocalIndex[ sizeof( uint8_t ) ];
        *pUsed = true;
        *pPropertyLength -= sizeof( uint8_t );

        if( *pProperty > 1U )
        {
            status = MQTTBadResponse;
        }
    }

    *pIndex = pLocalIndex;
    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t decodeUtf8( const char ** pProperty,
                                 uint16_t * pLength,
                                 size_t * pPropertyLength,
                                 bool * pUsed,
                                 uint8_t ** pIndex )
{
    uint8_t * pLocalIndex = *pIndex;
    MQTTStatus_t status = MQTTSuccess;

    /* Protocol error to include the same property twice. */
    if( *pUsed == true )
    {
        status = MQTTBadResponse;
    }
    /* Validate the length and decode. */
    else if( *pPropertyLength < sizeof( uint16_t ) )
    {
        status = MQTTBadResponse;
    }
    else
    {
        *pLength = UINT16_DECODE( pLocalIndex );
        pLocalIndex = &pLocalIndex[ sizeof( uint16_t ) ];
        *pPropertyLength -= sizeof( uint16_t );

        if( *pPropertyLength < *pLength )
        {
            status = MQTTBadResponse;
        }
        else
        {
            *pProperty = ( const char * ) pLocalIndex;
            pLocalIndex = &pLocalIndex[ *pLength ];
            *pPropertyLength -= *pLength;
            *pUsed = true;
        }
    }

    *pIndex = pLocalIndex;
    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t decodeBinaryData( const void ** pProperty,
                                      uint16_t * pLength,
                                      size_t * pPropertyLength,
                                      uint8_t ** pIndex )
{
    uint8_t * pLocalIndex = *pIndex;
    MQTTStatus_t status = MQTTSuccess;

    /* Validate the length and decode. */
    if( *pPropertyLength < sizeof( uint16_t ) )
    {
        status = MQTTBadResponse;
    }
    else
    {
        *pLength = UINT16_DECODE( pLocalIndex );
        pLocalIndex = &pLocalIndex[ sizeof( uint16_t ) ];
        *pPropertyLength -= sizeof( uint16_t );

        if( *pPropertyLength < *pLength )
        {
            status = MQTTBadResponse;
        }
        else
        {
            *pProperty = pLocalIndex;
            pLocalIndex = &pLocalIndex[ *pLength ];
            *pPropertyLength -= *pLength;
        }
    }

    *pIndex = pLocalIndex;
    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t decodeUserProp( const char ** pPropertyKey,
                                    uint16_t * pPropertyKeyLen,
                                    const char ** pPropertyValue,
                                    uint16_t * pPropertyValueLen,
                                    size_t * pPropertyLength,
                                    uint8_t ** pIndex )
{
    MQTTStatus_t status = MQTTSuccess;
    const char * pKey = NULL;
    const char * pValue = NULL;
    uint16_t keyLength = 0U;
    uint16_t valueLength = 0U;
    bool used = false;

    /* Decode the user property key using decodeUtf8. */
    status = decodeUtf8( &pKey, &keyLength, pPropertyLength, &used, pIndex );

    if( status == MQTTSuccess )
    {
        used = false;
        /* Decode the user property value using decodeUtf8. */
        status = decodeUtf8( &pValue, &valueLength, pPropertyLength, &used, pIndex );
    }

    if( status == MQTTSuccess )
    {
        /* Store the decoded key and value. */
        *pPropertyKey = pKey;
        *pPropertyKeyLen = keyLength;
        *pPropertyValue = pValue;
        *pPropertyValueLen = valueLength;
    }

    return status;
}

/*-----------------------------------------------------------*/

static MQTTStatus_t deserializeConnackProperties( MQTTConnectionProperties_t * pConnackProperties,
                                                  size_t length,
                                                  uint8_t * pIndex,
                                                  MQTTPropBuilder_t * pPropBuffer )
{
    MQTTStatus_t status = MQTTSuccess;
    uint8_t * pVariableHeader = pIndex;
    size_t propertyLength = length;
    bool sessionExpiry = false;
    bool serverReceiveMax = false;
    bool maxQos = false;
    bool retain = false;
    bool maxPacket = false;
    bool clientId = false;
    bool topicAlias = false;
    bool wildcard = false;
    bool subId = false;
    bool sharedsub = false;
    bool keepAlive = false;
    bool responseInfo = false;
    bool serverReference = false;
    bool authMethod = false;
    bool authData = false;
    bool reasonString = false;

    pVariableHeader = &pVariableHeader[ variableLengthEncodedSize( propertyLength ) ];

    if( pPropBuffer != NULL )
    {
        pPropBuffer->pBuffer = pVariableHeader;
        pPropBuffer->bufferLength = propertyLength;
    }

    /* Decode all the properties received, validate and store them in pConnackProperties. */
    while( ( propertyLength > 0U ) && ( status == MQTTSuccess ) )
    {
        uint8_t propertyId = *pVariableHeader;
        const char * data;
        uint16_t dataLength;

        pVariableHeader = &pVariableHeader[ 1 ];
        propertyLength -= sizeof( uint8_t );

        switch( propertyId )
        {
            /* In absence of this property, the value in the connect packet is used. */
            case MQTT_SESSION_EXPIRY_ID:
                status = decodeUint32t( &pConnackProperties->sessionExpiry, &propertyLength,
                                         &sessionExpiry, &pVariableHeader );
                break;

            case MQTT_RECEIVE_MAX_ID:
                status = decodeUint16t( &pConnackProperties->serverReceiveMax, &propertyLength,
                                         &serverReceiveMax, &pVariableHeader );

                /* Receive max cannot be 0. */
                if( ( status == MQTTSuccess ) && ( pConnackProperties->serverReceiveMax == 0U ) )
                {
                    LogError( ( "Receive Maximum value set to 0 by the server." ) );
                    status = MQTTBadResponse;
                }
                break;

            case MQTT_MAX_QOS_ID:
                status = decodeUint8t( &pConnackProperties->serverMaxQos, &propertyLength,
                                        &maxQos, &pVariableHeader );

                /* Protocol error for this value to be anything else except 0 or 1. */
                if( ( status == MQTTSuccess ) && 
                    ( pConnackProperties->serverMaxQos > 1U ) )
                {
                    LogError( ( "Invalid maximum QoS value set to %u (not 0 or 1) by the server.",
                                pConnackProperties->serverMaxQos ) );
                    status = MQTTBadResponse;
                }
                break;

            case MQTT_RETAIN_AVAILABLE_ID:
                status = decodeUint8t( &pConnackProperties->retainAvailable, &propertyLength,
                                        &retain, &pVariableHeader );

                /* Protocol error for this value to be anything else except 0 or 1. */
                if( ( status == MQTTSuccess ) && 
                    ( pConnackProperties->retainAvailable > 1U ) )
                {
                    LogError( ( "Invalid retain available value set by the server %u (not 0 or 1)",
                                pConnackProperties->retainAvailable ) );
                    status = MQTTBadResponse;
                }
                break;

            case MQTT_MAX_PACKET_SIZE_ID:
                status = decodeUint32t( &pConnackProperties->serverMaxPacketSize, &propertyLength,
                                         &maxPacket, &pVariableHeader );

                /* Protocol error for this value to be 0. */
                if( ( status == MQTTSuccess ) && 
                    ( pConnackProperties->serverMaxPacketSize == 0U ) )
                {
                    LogError( ( "Server set maximum packet size to 0. Invalid response." ) );
                    status = MQTTBadResponse;
                }
                break;

            case MQTT_ASSIGNED_CLIENT_ID:
                status = decodeUtf8( &data, &dataLength, &propertyLength, &clientId, &pVariableHeader );
                break;

            case MQTT_TOPIC_ALIAS_MAX_ID:
                status = decodeUint16t( &pConnackProperties->serverTopicAliasMax, &propertyLength,
                                         &topicAlias, &pVariableHeader );
                break;

            case MQTT_REASON_STRING_ID:
                status = decodeUtf8( &data, &dataLength, &propertyLength, &reasonString, &pVariableHeader );
                if( status == MQTTSuccess )
                {
                    /* Proper uses for the reason string in the Client would include using this information
                     * in an exception thrown by the Client code, or writing this string to a log. */
                    LogInfo( ( "Reason string from server: %.*s", dataLength, data ) );
                }
                break;

            case MQTT_USER_PROPERTY_ID:
                {
                    const char * key, *value;
                    uint16_t keyLength, valueLength;
                    status = decodeUserProp( &key, &keyLength, &value, &valueLength, &propertyLength, &pVariableHeader );
                }
                break;

            case MQTT_WILDCARD_ID:
                status = decodeUint8t( &pConnackProperties->isWildcardAvailable, &propertyLength,
                                        &wildcard, &pVariableHeader );

                /* Protocol error for this value to be anything except 0 or 1. */
                if( ( status == MQTTSuccess ) && 
                    ( pConnackProperties->isWildcardAvailable > 1U ) )
                {
                    LogError( ( "Server set wildcard value to %u (not 0 or 1). Invalid response.",
                                pConnackProperties->isWildcardAvailable ) );
                    status = MQTTBadResponse;
                }
                break;

            case MQTT_SUB_AVAILABLE_ID:
                status = decodeUint8t( &pConnackProperties->isSubscriptionIdAvailable, &propertyLength,
                                        &subId, &pVariableHeader );

                /* Protocol error for this value to be anything except 0 or 1. */
                if( ( status == MQTTSuccess ) && 
                    ( pConnackProperties->isSubscriptionIdAvailable > 1U ) )
                {
                    LogError( ( "Server set subscription ID availability to %u (not 0 or 1). Invalid response.",
                                pConnackProperties->isSubscriptionIdAvailable ) );
                    status = MQTTBadResponse;
                }
                break;

            case MQTT_SHARED_SUB_ID:
                status = decodeUint8t( &pConnackProperties->isSharedAvailable, &propertyLength,
                                       &sharedsub, &pVariableHeader );

                /* Protocol error for this value to be anything except 0 or 1. */
                if( ( status == MQTTSuccess ) && 
                    ( pConnackProperties->isSharedAvailable > 1U ) )
                {
                    LogError( ( "Server set shared sub availability to %u (not 0 or 1). Invalid response.",
                                pConnackProperties->isSharedAvailable ) );
                    status = MQTTBadResponse;
                }
                break;

            case MQTT_SERVER_KEEP_ALIVE_ID:
                status = decodeUint16t( &pConnackProperties->serverKeepAlive, &propertyLength,
                                         &keepAlive, &pVariableHeader );
                break;

            case MQTT_RESPONSE_INFO_ID:
                status = decodeUtf8( &data, &dataLength, &propertyLength, &responseInfo, &pVariableHeader );

                /* TODO: Decide if this should be somehow passed to the application. */

                /* Protocol error to send response information if the client has not requested it. */
                if( ( status == MQTTSuccess ) && ( pConnackProperties->requestResponseInfo == false ) )
                {
                    LogError( ( "Client did not request information still server sent it. Protocol error." ) );
                    status = MQTTBadResponse;
                }
                break;

            case MQTT_SERVER_REF_ID:
                status = decodeUtf8( &data, &dataLength, &propertyLength, &serverReference, &pVariableHeader );
                if( status == MQTTSuccess )
                {
                    LogInfo( ( "Server reference: %.*s", dataLength, data ) );
                }
                break;

            case MQTT_AUTH_METHOD_ID:
                status = decodeUtf8( &data, &dataLength, &propertyLength, &authMethod, &pVariableHeader );
                /* TODO: AUTH method should be returned to the application to allow the
                 * authentication to complete. */
                break;

            case MQTT_AUTH_DATA_ID:
                status = decodeUtf8( &data, &dataLength, &propertyLength, &authData, &pVariableHeader );
                /* TODO: AUTH Data should be returned to the application to allow the
                 * authentication to complete. */
                break;

            /* Protocol error to include any other property id. */
            default:
                status = MQTTBadResponse;
                break;
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

static uint8_t * encodeBinaryData( uint8_t * pDestination,
                                   const void * pSource,
                                   uint16_t sourceLength )
{
    uint8_t * pBuffer = NULL;

    /* Typecast const char * typed source buffer to const uint8_t *.
     * This is to use same type buffers in memcpy. */
    const uint8_t * pSourceBuffer = ( const uint8_t * ) pSource;

    assert( pDestination != NULL );
    assert( pSource != NULL );

    pBuffer = pDestination;

    /* The first byte of a UTF-8 string is the high byte of the string length. */
    *pBuffer = UINT16_HIGH_BYTE( sourceLength );
    pBuffer++;

    /* The second byte of a UTF-8 string is the low byte of the string length. */
    *pBuffer = UINT16_LOW_BYTE( sourceLength );
    pBuffer++;

    /* Copy the string into pBuffer. */

    ( void ) memcpy( pBuffer, pSourceBuffer, sourceLength );

    /* Return the pointer to the end of the encoded string. */
    pBuffer = &pBuffer[ sourceLength ];

    return pBuffer;
}

/*-----------------------------------------------------------*/

static bool isValidPropertyInPacketType( const uint8_t * mqttPacketType, uint8_t propBitLocation )
{
    bool isAllowed = false;
    uint32_t allowedPropertiesMask = 0U;

    /* Strip the lower 4 bits (flags) to get the base packet type. */
    uint8_t basePacketType = *mqttPacketType & 0xF0U;

    switch( basePacketType )
    {
        case MQTT_PACKET_TYPE_CONNECT:
            /* CONNECT properties:
             * - Session Expiry Interval
             * - Receive Maximum
             * - Maximum Packet Size
             * - Topic Alias Maximum
             * - Request Response Information
             * - Request Problem Information
             * - User Property
             * - Authentication Method
             * - Authentication Data
             */
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_SESSION_EXPIRY_INTERVAL_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_RECEIVE_MAXIMUM_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_MAX_PACKET_SIZE_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_TOPIC_ALIAS_MAX_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_REQUEST_RESPONSE_INFO_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_REQUEST_PROBLEM_INFO_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_USER_PROP_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_AUTHENTICATION_METHOD_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_AUTHENTICATION_DATA_POS );
            break;

        case MQTT_PACKET_TYPE_CONNACK:
            /* CONNACK properties:
             * - Session Expiry Interval
             * - Receive Maximum
             * - Maximum QoS
             * - Retain Available
             * - Maximum Packet Size
             * - Assigned Client Identifier
             * - Topic Alias Maximum
             * - Reason String
             * - User Property
             * - Wildcard Subscription Available
             * - Subscription Identifier Available
             * - Shared Subscription Available
             * - Server Keep Alive
             * - Response Information
             * - Server Reference
             * - Authentication Method
             * - Authentication Data
             */
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_SESSION_EXPIRY_INTERVAL_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_RECEIVE_MAXIMUM_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_MAXIMUM_QOS_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_RETAIN_AVAILABLE_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_MAX_PACKET_SIZE_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_ASSIGNED_CLIENT_ID_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_TOPIC_ALIAS_MAX_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_REASON_STRING_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_USER_PROP_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_WILDCARD_SUBSCRIPTION_AVAILABLE_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_SUBSCRIPTION_ID_AVAILABLE_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_SHARED_SUBSCRIPTION_AVAILABLE_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_SERVER_KEEP_ALIVE_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_RESPONSE_INFORMATION_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_SERVER_REFERENCE_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_AUTHENTICATION_METHOD_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_AUTHENTICATION_DATA_POS );
            break;

        case MQTT_PACKET_TYPE_PUBLISH:
            /* PUBLISH properties:
             * - Payload Format Indicator
             * - Message Expiry Interval
             * - Topic Alias
             * - Response Topic
             * - Correlation Data
             * - User Property
             * - Subscription Identifier (only in server-to-client PUBLISH)
             * - Content Type
             */
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_PAYLOAD_FORMAT_INDICATOR_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_MESSAGE_EXPIRY_INTERVAL_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_TOPIC_ALIAS_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_RESPONSE_TOPIC_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_CORRELATION_DATA_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_USER_PROP_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_SUBSCRIPTION_ID_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_CONTENT_TYPE_POS );
            break;

        case MQTT_PACKET_TYPE_PUBACK:
        case MQTT_PACKET_TYPE_PUBREC:
        case MQTT_PACKET_TYPE_PUBREL:
        case MQTT_PACKET_TYPE_PUBCOMP:
            /* PUBACK, PUBREC, PUBREL, PUBCOMP properties:
             * - Reason String
             * - User Property
             */
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_REASON_STRING_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_USER_PROP_POS );
            break;

        case MQTT_PACKET_TYPE_SUBSCRIBE:
            /* SUBSCRIBE properties:
             * - Subscription Identifier
             * - User Property
             */
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_SUBSCRIPTION_ID_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_USER_PROP_POS );
            break;

        case MQTT_PACKET_TYPE_SUBACK:
            /* SUBACK properties:
             * - Reason String
             * - User Property
             */
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_REASON_STRING_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_USER_PROP_POS );
            break;

        case MQTT_PACKET_TYPE_UNSUBSCRIBE:
            /* UNSUBSCRIBE properties:
             * - User Property
             */
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_USER_PROP_POS );
            break;

        case MQTT_PACKET_TYPE_UNSUBACK:
            /* UNSUBACK properties:
             * - Reason String
             * - User Property
             */
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_REASON_STRING_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_USER_PROP_POS );
            break;

        case MQTT_PACKET_TYPE_DISCONNECT:
            /* DISCONNECT properties:
             * - Session Expiry Interval
             * - Reason String
             * - User Property
             * - Server Reference
             */
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_SESSION_EXPIRY_INTERVAL_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_REASON_STRING_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_USER_PROP_POS );
            UINT32_SET_BIT( allowedPropertiesMask, MQTT_SERVER_REFERENCE_POS );
            break;

        case MQTT_PACKET_TYPE_PINGREQ:
        case MQTT_PACKET_TYPE_PINGRESP:
            /* PINGREQ and PINGRESP have no properties section.
             * allowedPropertiesMask remains 0. */
            break;

        default:
            /* Unknown packet type - no properties allowed. */
            break;
    }

    /* Check if the property bit is set in the allowed mask. */
    isAllowed = UINT32_CHECK_BIT( allowedPropertiesMask, propBitLocation );

    return isAllowed;
}


/*-----------------------------------------------------------*/

uint8_t * MQTT_SerializeConnectFixedHeader( uint8_t * pIndex,
                                            const MQTTConnectInfo_t * pConnectInfo,
                                            const MQTTPublishInfo_t * pWillInfo,
                                            size_t remainingLength )
{
    uint8_t * pIndexLocal = pIndex;
    uint8_t connectFlags = 0U;

    /* The first byte in the CONNECT packet is the control packet type. */
    *pIndexLocal = MQTT_PACKET_TYPE_CONNECT;
    pIndexLocal++;

    /* The remaining length of the CONNECT packet is encoded starting from the
     * second byte. The remaining length does not include the length of the fixed
     * header or the encoding of the remaining length. */
    pIndexLocal = encodeVariableLength( pIndexLocal, remainingLength );

    /* The string "MQTT" is placed at the beginning of the CONNECT packet's variable
     * header. This string is 4 bytes long. */
    pIndexLocal = encodeString( pIndexLocal, "MQTT", 4 );

    /* The MQTT protocol version is the second field of the variable header. */

    *pIndexLocal = MQTT_VERSION_5;

    pIndexLocal++;

    /* Set the clean session flag if needed. */
    if( pConnectInfo->cleanSession == true )
    {
        UINT8_SET_BIT( connectFlags, MQTT_CONNECT_FLAG_CLEAN );
    }

    /* Set the flags for username and password if provided. */
    if( pConnectInfo->pUserName != NULL )
    {
        UINT8_SET_BIT( connectFlags, MQTT_CONNECT_FLAG_USERNAME );
    }

    if( pConnectInfo->pPassword != NULL )
    {
        UINT8_SET_BIT( connectFlags, MQTT_CONNECT_FLAG_PASSWORD );
    }

    /* Set will flag if a Last Will and Testament is provided. */
    if( pWillInfo != NULL )
    {
        UINT8_SET_BIT( connectFlags, MQTT_CONNECT_FLAG_WILL );

        /* Flags only need to be changed for Will QoS 1 or 2. */
        if( pWillInfo->qos == MQTTQoS1 )
        {
            UINT8_SET_BIT( connectFlags, MQTT_CONNECT_FLAG_WILL_QOS1 );
        }
        else if( pWillInfo->qos == MQTTQoS2 )
        {
            UINT8_SET_BIT( connectFlags, MQTT_CONNECT_FLAG_WILL_QOS2 );
        }
        else
        {
            /* Empty else MISRA 15.7 */
        }

        if( pWillInfo->retain == true )
        {
            UINT8_SET_BIT( connectFlags, MQTT_CONNECT_FLAG_WILL_RETAIN );
        }
    }

    *pIndexLocal = connectFlags;
    pIndexLocal++;

    /* Write the 2 bytes of the keep alive interval into the CONNECT packet. */
    pIndexLocal[ 0 ] = UINT16_HIGH_BYTE( pConnectInfo->keepAliveSeconds );
    pIndexLocal[ 1 ] = UINT16_LOW_BYTE( pConnectInfo->keepAliveSeconds );
    pIndexLocal = &pIndexLocal[ 2 ];

    return pIndexLocal;
}

/*-----------------------------------------------------------*/

static void serializeConnectPacket( const MQTTConnectInfo_t * pConnectInfo,
                                    const MQTTPublishInfo_t * pWillInfo,
                                    size_t remainingLength,
                                    const MQTTFixedBuffer_t * pFixedBuffer )
{
    uint8_t * pIndex = NULL;

    assert( pConnectInfo != NULL );
    assert( pFixedBuffer != NULL );
    assert( pFixedBuffer->pBuffer != NULL );

    pIndex = pFixedBuffer->pBuffer;

    /* Serialize the header. */
    pIndex = MQTT_SerializeConnectFixedHeader( pIndex,
                                               pConnectInfo,
                                               pWillInfo,
                                               remainingLength );

    /* Write the client identifier into the CONNECT packet. */
    pIndex = encodeString( pIndex,
                           pConnectInfo->pClientIdentifier,
                           pConnectInfo->clientIdentifierLength );

    /* Write the will topic name and message into the CONNECT packet if provided. */
    if( pWillInfo != NULL )
    {
        pIndex = encodeString( pIndex,
                               pWillInfo->pTopicName,
                               pWillInfo->topicNameLength );

        pIndex = encodeString( pIndex,
                               pWillInfo->pPayload,
                               ( uint16_t ) pWillInfo->payloadLength );
    }

    /* Encode the user name if provided. */
    if( pConnectInfo->pUserName != NULL )
    {
        pIndex = encodeString( pIndex, pConnectInfo->pUserName, pConnectInfo->userNameLength );
    }

    /* Encode the password if provided. */
    if( pConnectInfo->pPassword != NULL )
    {
        pIndex = encodeString( pIndex, pConnectInfo->pPassword, pConnectInfo->passwordLength );
    }

    LogDebug( ( "Length of serialized CONNECT packet is %lu.",
                ( ( unsigned long ) ( pIndex - pFixedBuffer->pBuffer ) ) ) );

    /* Ensure that the difference between the end and beginning of the buffer
     * is less than the buffer size. */
    assert( ( ( size_t ) ( pIndex - pFixedBuffer->pBuffer ) ) <= pFixedBuffer->size );
}

/*-----------------------------------------------------------*/

uint8_t * encodeVariableLength( uint8_t * pDestination,
                                size_t length )
{
    uint8_t lengthByte;
    uint8_t * pLengthEnd = NULL;
    size_t remainingLength = length;

    assert( pDestination != NULL );

    pLengthEnd = pDestination;

    /* This algorithm is copied from the MQTT 5.0 spec. */
    do
    {
        lengthByte = ( uint8_t ) ( remainingLength % 128U );
        remainingLength = remainingLength / 128U;

        /* Set the high bit of this byte, indicating that there's more data. */
        if( remainingLength > 0U )
        {
            UINT8_SET_BIT( lengthByte, 7 );
        }

        /* Output a single encoded byte. */
        *pLengthEnd = lengthByte;
        pLengthEnd++;
    } while( remainingLength > 0U );

    return pLengthEnd;
}

/*-----------------------------------------------------------*/

MQTTStatus_t updateContextWithConnectProps( const MQTTPropBuilder_t * pPropBuilder,
                                            MQTTConnectionProperties_t * pConnectProperties )
{
    MQTTStatus_t status = MQTTSuccess;

    if( pPropBuilder == NULL )
    {
        LogError( ( "pPropBuilder cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pPropBuilder->pBuffer == NULL )
    {
        LogError( ( "pPropBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pConnectProperties == NULL )
    {
        LogError( ( "pConnectProperties cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else
    {
        bool maxPacket = false;
        bool sessionExpiry = false;
        bool receiveMax = false;
        bool topicAlias = false;
        size_t propertyLength = 0U;
        uint8_t * pIndex;

        propertyLength = pPropBuilder->currentIndex;
        pIndex = pPropBuilder->pBuffer; /* Pointer to the buffer */

        while( ( propertyLength > 0U ) && ( status == MQTTSuccess ) )
        {
            uint8_t propertyId = *pIndex;
            bool used = false;
            pIndex = &pIndex[ 1 ];
            propertyLength--;

            switch( propertyId )
            {
                case MQTT_SESSION_EXPIRY_ID:

                    /**
                     * This value shall get overwritten if the server sends a sessionExpiry
                     * in the CONNACK.
                     */
                    status = decodeUint32t( &pConnectProperties->sessionExpiry, &propertyLength,
                                             &sessionExpiry, &pIndex );
                    break;

                case MQTT_RECEIVE_MAX_ID:
                    status = decodeUint16t( &pConnectProperties->receiveMax, &propertyLength,
                                             &receiveMax, &pIndex );
                    break;

                case MQTT_MAX_PACKET_SIZE_ID:
                    status = decodeUint32t( &pConnectProperties->maxPacketSize, &propertyLength,
                                             &maxPacket, &pIndex );
                    break;

                case MQTT_TOPIC_ALIAS_MAX_ID:
                    status = decodeUint16t( &pConnectProperties->topicAliasMax, &propertyLength,
                                             &topicAlias, &pIndex );
                    break;

                case MQTT_REQUEST_PROBLEM_ID:
                case MQTT_REQUEST_RESPONSE_ID:
                    {
                        uint8_t property;
                        /* TODO: should this go in the context? */
                        status = decodeUint8t( &property, &propertyLength, &used, &pIndex );
                    }
                    break;

                case MQTT_AUTH_DATA_ID:
                case MQTT_AUTH_METHOD_ID:
                    {
                        const char * data;
                        uint16_t dataLength;
                        status = decodeUtf8( &data, &dataLength, &propertyLength, &used, &pIndex );
                    }
                    break;

                case MQTT_USER_PROPERTY_ID:
                    {
                        const char *key, *value;
                        uint16_t keyLength, valueLength;
                        status = decodeUserProp( &key,
                                                &keyLength,
                                                &value,
                                                &valueLength,
                                                &propertyLength,
                                                &pIndex );
                    }
                    break;

                default:
                    status = MQTTBadParameter;
                    break;
            }
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_GetConnectPacketSize( const MQTTConnectInfo_t * pConnectInfo,
                                        const MQTTPublishInfo_t * pWillInfo,
                                        const MQTTPropBuilder_t * pConnectProperties,
                                        const MQTTPropBuilder_t * pWillProperties,
                                        size_t * pRemainingLength,
                                        size_t * pPacketSize )
{
    MQTTStatus_t status = MQTTSuccess;
    size_t remainingLength;
    size_t propertyLength = 0U;
    size_t willPropertyLength = 0U;

    /* The CONNECT packet will always include a 10-byte variable header without connect properties. */
    size_t connectPacketSize = MQTT_PACKET_CONNECT_HEADER_SIZE;

    /* Validate arguments. */
    if( ( pConnectInfo == NULL ) || ( pRemainingLength == NULL ) ||
        ( pPacketSize == NULL ) )
    {
        LogError( ( "Argument cannot be NULL: pConnectInfo=%p, "
                    "pRemainingLength=%p, pPacketSize=%p.",
                    ( void * ) pConnectInfo,
                    ( void * ) pRemainingLength,
                    ( void * ) pPacketSize ) );
        status = MQTTBadParameter;
    }
    else if( ( pConnectInfo->clientIdentifierLength == 0U ) ^
             ( ( pConnectInfo->pClientIdentifier == NULL ) || ( *( pConnectInfo->pClientIdentifier ) == '\0' ) ) )
    {
        LogError( ( "Client ID length and value mismatch." ) );
        status = MQTTBadParameter;
    }
    else if( ( pWillInfo != NULL ) && ( pWillInfo->payloadLength > ( size_t ) UINT16_MAX ) )
    {
        /* The MQTTPublishInfo_t is reused for the will message. The payload
         * length for any other message could be larger than 65,535, but
         * the will message length is required to be represented in 2 bytes. */
        LogError( ( "The Will Message length must not exceed %d. "
                    "pWillInfo->payloadLength=%lu.",
                    UINT16_MAX,
                    ( unsigned long ) pWillInfo->payloadLength ) );
        status = MQTTBadParameter;
    }
    else
    {
        /* Do Nothing. */
    }

    if( ( pConnectProperties != NULL ) && ( pConnectProperties->pBuffer != NULL ) )
    {
        propertyLength = pConnectProperties->currentIndex;
    }

    if( ( pWillProperties != NULL ) && ( pWillProperties->pBuffer != NULL ) )
    {
        willPropertyLength = pWillProperties->currentIndex;
    }

    if( status == MQTTSuccess )
    {
        /* Add the length of the properties. */
        connectPacketSize += propertyLength;
        connectPacketSize += variableLengthEncodedSize( propertyLength );

        /* Add the length of the client identifier. */
        connectPacketSize += pConnectInfo->clientIdentifierLength + sizeof( uint16_t );

        /* Add the lengths of the will message, topic name and properties if provided. */
        if( pWillInfo != NULL )
        {
            connectPacketSize += willPropertyLength;
            connectPacketSize += variableLengthEncodedSize( willPropertyLength );
            connectPacketSize += pWillInfo->topicNameLength + sizeof( uint16_t ) +
                                 pWillInfo->payloadLength + sizeof( uint16_t );
        }

        /* Add the lengths of the user name and password if provided. */
        if( pConnectInfo->pUserName != NULL )
        {
            connectPacketSize += pConnectInfo->userNameLength + sizeof( uint16_t );
        }

        if( pConnectInfo->pPassword != NULL )
        {
            connectPacketSize += pConnectInfo->passwordLength + sizeof( uint16_t );
        }

        /* At this point, the "Remaining Length" field of the MQTT CONNECT packet has
         * been calculated. */
        remainingLength = connectPacketSize;

        /* Calculate the full size of the MQTT CONNECT packet by adding the size of
         * the "Remaining Length" field plus 1 byte for the "Packet Type" field. */
        connectPacketSize += 1U + variableLengthEncodedSize( connectPacketSize );

        /*
         * It is possible that the remaining length becomes more than the maximum
         * allowed by the MQTTV5-Spec, i.e. 268,435,455. This is because the user may
         * enter a large number of user properties for the connect packet and/or
         * the last will.
         * Hence we need to have a check for this case
         */
        if( remainingLength > MQTT_MAX_REMAINING_LENGTH )
        {
            LogError( ( "Packet remaining length exceeds the maximum allowed size." ) );
            status = MQTTBadParameter;
        }
    }

    if( status == MQTTSuccess )
    {
        *pRemainingLength = remainingLength;
        *pPacketSize = connectPacketSize;

        LogDebug( ( "CONNECT packet remaining length=%lu and packet size=%lu.",
                    ( unsigned long ) *pRemainingLength,
                    ( unsigned long ) *pPacketSize ) );
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_SerializeConnect( const MQTTConnectInfo_t * pConnectInfo,
                                    const MQTTPublishInfo_t * pWillInfo,
                                    size_t remainingLength,
                                    const MQTTFixedBuffer_t * pFixedBuffer )
{
    MQTTStatus_t status = MQTTSuccess;
    size_t connectPacketSize = 0;

    /* Validate arguments. */
    if( ( pConnectInfo == NULL ) || ( pFixedBuffer == NULL ) )
    {
        LogError( ( "Argument cannot be NULL: pConnectInfo=%p, "
                    "pFixedBuffer=%p.",
                    ( void * ) pConnectInfo,
                    ( void * ) pFixedBuffer ) );
        status = MQTTBadParameter;
    }
    /* A buffer must be configured for serialization. */
    else if( pFixedBuffer->pBuffer == NULL )
    {
        LogError( ( "Argument cannot be NULL: pFixedBuffer->pBuffer is NULL." ) );
        status = MQTTBadParameter;
    }
    else if( ( pWillInfo != NULL ) && ( pWillInfo->pTopicName == NULL ) )
    {
        LogError( ( "pWillInfo->pTopicName cannot be NULL if Will is present." ) );
        status = MQTTBadParameter;
    }
    else
    {
        /* Calculate CONNECT packet size. Overflow in in this addition is not checked
         * because it is part of the API contract to call Mqtt_GetConnectPacketSize()
         * before this function. */
        connectPacketSize = remainingLength + remainingLengthEncodedSize( remainingLength ) + 1U;

        /* Check that the full packet size fits within the given buffer. */
        if( connectPacketSize > pFixedBuffer->size )
        {
            LogError( ( "Buffer size of %lu is not sufficient to hold "
                        "serialized CONNECT packet of size of %lu.",
                        ( unsigned long ) pFixedBuffer->size,
                        ( unsigned long ) connectPacketSize ) );
            status = MQTTNoMemory;
        }
        else
        {
            serializeConnectPacket( pConnectInfo,
                                    pWillInfo,
                                    remainingLength,
                                    pFixedBuffer );
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_GetSubscribePacketSize( const MQTTSubscribeInfo_t * pSubscriptionList,
                                          size_t subscriptionCount,
                                          size_t * pRemainingLength,
                                          size_t * pPacketSize )
{
    MQTTStatus_t status = MQTTSuccess;

    /* Validate parameters. */
    if( ( pSubscriptionList == NULL ) || ( pRemainingLength == NULL ) ||
        ( pPacketSize == NULL ) )
    {
        LogError( ( "Argument cannot be NULL: pSubscriptionList=%p, "
                    "pRemainingLength=%p, pPacketSize=%p.",
                    ( void * ) pSubscriptionList,
                    ( void * ) pRemainingLength,
                    ( void * ) pPacketSize ) );
        status = MQTTBadParameter;
    }
    else if( subscriptionCount == 0U )
    {
        LogError( ( "subscriptionCount is 0." ) );
        status = MQTTBadParameter;
    }
    else
    {
        /* Calculate the MQTT SUBSCRIBE packet size. */
        status = calculateSubscriptionPacketSize( pSubscriptionList,
                                                  subscriptionCount,
                                                  pRemainingLength,
                                                  pPacketSize,
                                                  MQTT_SUBSCRIBE );
    }

    return status;
}

/*-----------------------------------------------------------*/

uint8_t * MQTT_SerializeSubscribeHeader( size_t remainingLength,
                                         uint8_t * pIndex,
                                         uint16_t packetId )
{
    uint8_t * pIterator = pIndex;

    /* The first byte in SUBSCRIBE is the packet type. */
    *pIterator = MQTT_PACKET_TYPE_SUBSCRIBE;
    pIterator++;

    /* Encode the "Remaining length" starting from the second byte. */
    pIterator = encodeRemainingLength( pIterator, remainingLength );

    /* Place the packet identifier into the SUBSCRIBE packet. */
    pIterator[ 0 ] = UINT16_HIGH_BYTE( packetId );
    pIterator[ 1 ] = UINT16_LOW_BYTE( packetId );
    /* Advance the pointer. */
    pIterator = &pIterator[ 2 ];

    return pIterator;
}

/*-----------------------------------------------------------*/

uint8_t * MQTT_SerializeUnsubscribeHeader( size_t remainingLength,
                                           uint8_t * pIndex,
                                           uint16_t packetId )
{
    uint8_t * pIterator = pIndex;

    /* The first byte in UNSUBSCRIBE is the packet type. */
    *pIterator = MQTT_PACKET_TYPE_UNSUBSCRIBE;
    pIterator++;

    /* Encode the "Remaining length" starting from the second byte. */
    pIterator = encodeRemainingLength( pIterator, remainingLength );

    /* Place the packet identifier into the SUBSCRIBE packet. */
    pIterator[ 0 ] = UINT16_HIGH_BYTE( packetId );
    pIterator[ 1 ] = UINT16_LOW_BYTE( packetId );
    /* Increment the pointer. */
    pIterator = &pIterator[ 2 ];

    return pIterator;
}

MQTTStatus_t MQTT_SerializeSubscribe( const MQTTSubscribeInfo_t * pSubscriptionList,
                                      size_t subscriptionCount,
                                      uint16_t packetId,
                                      size_t remainingLength,
                                      const MQTTFixedBuffer_t * pFixedBuffer )
{
    size_t i = 0;
    uint8_t * pIndex = NULL;

    /* Validate all the parameters. */
    MQTTStatus_t status =
        validateSubscriptionSerializeParams( pSubscriptionList,
                                             subscriptionCount,
                                             packetId,
                                             remainingLength,
                                             pFixedBuffer );

    if( status == MQTTSuccess )
    {
        pIndex = pFixedBuffer->pBuffer;

        pIndex = MQTT_SerializeSubscribeHeader( remainingLength,
                                                pIndex,
                                                packetId );

        /* Serialize each subscription topic filter and QoS. */
        for( i = 0; i < subscriptionCount; i++ )
        {
            pIndex = encodeString( pIndex,
                                   pSubscriptionList[ i ].pTopicFilter,
                                   pSubscriptionList[ i ].topicFilterLength );

            /* Place the QoS in the SUBSCRIBE packet. */
            *pIndex = ( uint8_t ) ( pSubscriptionList[ i ].qos );
            pIndex++;
        }

        LogDebug( ( "Length of serialized SUBSCRIBE packet is %lu.",
                    ( ( unsigned long ) ( pIndex - pFixedBuffer->pBuffer ) ) ) );
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_GetUnsubscribePacketSize( const MQTTSubscribeInfo_t * pSubscriptionList,
                                            size_t subscriptionCount,
                                            size_t * pRemainingLength,
                                            size_t * pPacketSize )
{
    MQTTStatus_t status = MQTTSuccess;

    /* Validate parameters. */
    if( ( pSubscriptionList == NULL ) || ( pRemainingLength == NULL ) ||
        ( pPacketSize == NULL ) )
    {
        LogError( ( "Argument cannot be NULL: pSubscriptionList=%p, "
                    "pRemainingLength=%p, pPacketSize=%p.",
                    ( void * ) pSubscriptionList,
                    ( void * ) pRemainingLength,
                    ( void * ) pPacketSize ) );
        status = MQTTBadParameter;
    }
    else if( subscriptionCount == 0U )
    {
        LogError( ( "Subscription count is 0." ) );
        status = MQTTBadParameter;
    }
    else
    {
        /* Calculate the MQTT UNSUBSCRIBE packet size. */
        status = calculateSubscriptionPacketSize( pSubscriptionList,
                                                  subscriptionCount,
                                                  pRemainingLength,
                                                  pPacketSize,
                                                  MQTT_UNSUBSCRIBE );
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_SerializeUnsubscribe( const MQTTSubscribeInfo_t * pSubscriptionList,
                                        size_t subscriptionCount,
                                        uint16_t packetId,
                                        size_t remainingLength,
                                        const MQTTFixedBuffer_t * pFixedBuffer )
{
    MQTTStatus_t status = MQTTSuccess;
    size_t i = 0;
    uint8_t * pIndex = NULL;

    /* Validate all the parameters. */
    status = validateSubscriptionSerializeParams( pSubscriptionList,
                                                  subscriptionCount,
                                                  packetId,
                                                  remainingLength,
                                                  pFixedBuffer );

    if( status == MQTTSuccess )
    {
        /* Get the start of the buffer to the iterator variable. */
        pIndex = pFixedBuffer->pBuffer;

        pIndex = MQTT_SerializeUnsubscribeHeader( remainingLength, pIndex, packetId );

        /* Serialize each subscription topic filter. */
        for( i = 0; i < subscriptionCount; i++ )
        {
            pIndex = encodeString( pIndex,
                                   pSubscriptionList[ i ].pTopicFilter,
                                   pSubscriptionList[ i ].topicFilterLength );
        }

        LogDebug( ( "Length of serialized UNSUBSCRIBE packet is %lu.",
                    ( ( unsigned long ) ( pIndex - pFixedBuffer->pBuffer ) ) ) );
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_GetPublishPacketSize( const MQTTPublishInfo_t * pPublishInfo,
                                        size_t * pRemainingLength,
                                        size_t * pPacketSize )
{
    MQTTStatus_t status = MQTTSuccess;

    if( ( pPublishInfo == NULL ) || ( pRemainingLength == NULL ) || ( pPacketSize == NULL ) )
    {
        LogError( ( "Argument cannot be NULL: pPublishInfo=%p, "
                    "pRemainingLength=%p, pPacketSize=%p.",
                    ( void * ) pPublishInfo,
                    ( void * ) pRemainingLength,
                    ( void * ) pPacketSize ) );
        status = MQTTBadParameter;
    }
    else if( ( pPublishInfo->pTopicName == NULL ) || ( pPublishInfo->topicNameLength == 0U ) )
    {
        LogError( ( "Invalid topic name for PUBLISH: pTopicName=%p, "
                    "topicNameLength=%hu.",
                    ( void * ) pPublishInfo->pTopicName,
                    ( unsigned short ) pPublishInfo->topicNameLength ) );
        status = MQTTBadParameter;
    }
    else
    {
        /* Calculate the "Remaining length" field and total packet size. If it exceeds
         * what is allowed in the MQTT standard, return an error. */
        if( calculatePublishPacketSize( pPublishInfo, pRemainingLength, pPacketSize ) == false )
        {
            LogError( ( "PUBLISH packet remaining length exceeds %lu, which is the "
                        "maximum size allowed by MQTT 3.1.1.",
                        MQTT_MAX_REMAINING_LENGTH ) );
            status = MQTTBadParameter;
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_SerializePublish( const MQTTPublishInfo_t * pPublishInfo,
                                    uint16_t packetId,
                                    size_t remainingLength,
                                    const MQTTFixedBuffer_t * pFixedBuffer )
{
    MQTTStatus_t status = MQTTSuccess;
    size_t packetSize = 0;

    if( ( pFixedBuffer == NULL ) || ( pPublishInfo == NULL ) )
    {
        LogError( ( "Argument cannot be NULL: pFixedBuffer=%p, "
                    "pPublishInfo=%p.",
                    ( void * ) pFixedBuffer,
                    ( void * ) pPublishInfo ) );
        status = MQTTBadParameter;
    }
    /* A buffer must be configured for serialization. */
    else if( pFixedBuffer->pBuffer == NULL )
    {
        LogError( ( "Argument cannot be NULL: pFixedBuffer->pBuffer is NULL." ) );
        status = MQTTBadParameter;
    }

    /* For serializing a publish, if there exists a payload, then the buffer
     * cannot be NULL. */
    else if( ( pPublishInfo->payloadLength > 0U ) && ( pPublishInfo->pPayload == NULL ) )
    {
        LogError( ( "A nonzero payload length requires a non-NULL payload: "
                    "payloadLength=%lu, pPayload=%p.",
                    ( unsigned long ) pPublishInfo->payloadLength,
                    pPublishInfo->pPayload ) );
        status = MQTTBadParameter;
    }
    else if( ( pPublishInfo->pTopicName == NULL ) || ( pPublishInfo->topicNameLength == 0U ) )
    {
        LogError( ( "Invalid topic name for PUBLISH: pTopicName=%p, "
                    "topicNameLength=%hu.",
                    ( void * ) pPublishInfo->pTopicName,
                    ( unsigned short ) pPublishInfo->topicNameLength ) );
        status = MQTTBadParameter;
    }
    else if( ( pPublishInfo->qos != MQTTQoS0 ) && ( packetId == 0U ) )
    {
        LogError( ( "Packet ID is 0 for PUBLISH with QoS=%u.",
                    ( unsigned int ) pPublishInfo->qos ) );
        status = MQTTBadParameter;
    }
    else if( ( pPublishInfo->dup == true ) && ( pPublishInfo->qos == MQTTQoS0 ) )
    {
        LogError( ( "Duplicate flag is set for PUBLISH with Qos 0." ) );
        status = MQTTBadParameter;
    }
    else
    {
        /* Length of serialized packet = First byte
         *                                + Length of encoded remaining length
         *                                + Remaining length. */
        packetSize = 1U + remainingLengthEncodedSize( remainingLength )
                     + remainingLength;
    }

    if( ( status == MQTTSuccess ) && ( packetSize > pFixedBuffer->size ) )
    {
        LogError( ( "Buffer size of %lu is not sufficient to hold "
                    "serialized PUBLISH packet of size of %lu.",
                    ( unsigned long ) pFixedBuffer->size,
                    ( unsigned long ) packetSize ) );
        status = MQTTNoMemory;
    }

    if( status == MQTTSuccess )
    {
        /* Serialize publish with header and payload. */
        serializePublishCommon( pPublishInfo,
                                remainingLength,
                                packetId,
                                pFixedBuffer,
                                true );
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_SerializePublishHeader( const MQTTPublishInfo_t * pPublishInfo,
                                          uint16_t packetId,
                                          size_t remainingLength,
                                          const MQTTFixedBuffer_t * pFixedBuffer,
                                          size_t * pHeaderSize )
{
    MQTTStatus_t status = MQTTSuccess;
    size_t packetSize = 0;

    if( ( pFixedBuffer == NULL ) || ( pPublishInfo == NULL ) ||
        ( pHeaderSize == NULL ) )
    {
        LogError( ( "Argument cannot be NULL: pFixedBuffer=%p, "
                    "pPublishInfo=%p, pHeaderSize=%p.",
                    ( void * ) pFixedBuffer,
                    ( void * ) pPublishInfo,
                    ( void * ) pHeaderSize ) );
        status = MQTTBadParameter;
    }
    /* A buffer must be configured for serialization. */
    else if( pFixedBuffer->pBuffer == NULL )
    {
        LogError( ( "Argument cannot be NULL: pFixedBuffer->pBuffer is NULL." ) );
        status = MQTTBadParameter;
    }
    else if( ( pPublishInfo->pTopicName == NULL ) || ( pPublishInfo->topicNameLength == 0U ) )
    {
        LogError( ( "Invalid topic name for publish: pTopicName=%p, "
                    "topicNameLength=%hu.",
                    ( void * ) pPublishInfo->pTopicName,
                    ( unsigned short ) pPublishInfo->topicNameLength ) );
        status = MQTTBadParameter;
    }
    else if( ( pPublishInfo->qos != MQTTQoS0 ) && ( packetId == 0U ) )
    {
        LogError( ( "Packet Id is 0 for publish with QoS=%hu.",
                    ( unsigned short ) pPublishInfo->qos ) );
        status = MQTTBadParameter;
    }
    else if( ( pPublishInfo->dup == true ) && ( pPublishInfo->qos == MQTTQoS0 ) )
    {
        LogError( ( "Duplicate flag is set for PUBLISH with Qos 0." ) );
        status = MQTTBadParameter;
    }
    else
    {
        /* Length of serialized packet = First byte
         *                               + Length of encoded remaining length
         *                               + Remaining length
         *                               - Payload Length.
         */
        packetSize = 1U + remainingLengthEncodedSize( remainingLength )
                     + remainingLength
                     - pPublishInfo->payloadLength;
    }

    if( ( status == MQTTSuccess ) && ( packetSize > pFixedBuffer->size ) )
    {
        LogError( ( "Buffer size of %lu is not sufficient to hold "
                    "serialized PUBLISH header packet of size of %lu.",
                    ( unsigned long ) pFixedBuffer->size,
                    ( unsigned long ) ( packetSize - pPublishInfo->payloadLength ) ) );
        status = MQTTNoMemory;
    }

    if( status == MQTTSuccess )
    {
        /* Serialize publish without copying the payload. */
        serializePublishCommon( pPublishInfo,
                                remainingLength,
                                packetId,
                                pFixedBuffer,
                                false );

        /* Header size is the same as calculated packet size. */
        *pHeaderSize = packetSize;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_SerializeAck( const MQTTFixedBuffer_t * pFixedBuffer,
                                uint8_t packetType,
                                uint16_t packetId )
{
    MQTTStatus_t status = MQTTSuccess;

    if( pFixedBuffer == NULL )
    {
        LogError( ( "Provided buffer is NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pFixedBuffer->pBuffer == NULL )
    {
        LogError( ( "pFixedBuffer->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    /* The buffer must be able to fit 4 bytes for the packet. */
    else if( pFixedBuffer->size < MQTT_PUBLISH_ACK_PACKET_SIZE )
    {
        LogError( ( "Insufficient memory for packet." ) );
        status = MQTTNoMemory;
    }
    else if( packetId == 0U )
    {
        LogError( ( "Packet ID cannot be 0." ) );
        status = MQTTBadParameter;
    }
    else
    {
        switch( packetType )
        {
            /* Only publish acks are serialized by the client. */
            case MQTT_PACKET_TYPE_PUBACK:
            case MQTT_PACKET_TYPE_PUBREC:
            case MQTT_PACKET_TYPE_PUBREL:
            case MQTT_PACKET_TYPE_PUBCOMP:
                pFixedBuffer->pBuffer[ 0 ] = packetType;
                pFixedBuffer->pBuffer[ 1 ] = MQTT_PACKET_SIMPLE_ACK_REMAINING_LENGTH;
                pFixedBuffer->pBuffer[ 2 ] = UINT16_HIGH_BYTE( packetId );
                pFixedBuffer->pBuffer[ 3 ] = UINT16_LOW_BYTE( packetId );
                break;

            default:
                LogError( ( "Packet type is not a publish ACK: Packet type=%02x",
                            ( unsigned int ) packetType ) );
                status = MQTTBadParameter;
                break;
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_GetDisconnectPacketSize( size_t * pPacketSize )
{
    MQTTStatus_t status = MQTTSuccess;

    if( pPacketSize == NULL )
    {
        LogError( ( "pPacketSize is NULL." ) );
        status = MQTTBadParameter;
    }
    else
    {
        /* MQTT DISCONNECT packets always have the same size. */
        *pPacketSize = MQTT_DISCONNECT_PACKET_SIZE;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_SerializeDisconnect( const MQTTFixedBuffer_t * pFixedBuffer )
{
    MQTTStatus_t status = MQTTSuccess;

    /* Validate arguments. */
    if( pFixedBuffer == NULL )
    {
        LogError( ( "pFixedBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pFixedBuffer->pBuffer == NULL )
    {
        LogError( ( "pFixedBuffer->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else
    {
        /* Empty else MISRA 15.7 */
    }

    if( status == MQTTSuccess )
    {
        if( pFixedBuffer->size < MQTT_DISCONNECT_PACKET_SIZE )
        {
            LogError( ( "Buffer size of %lu is not sufficient to hold "
                        "serialized DISCONNECT packet of size of %lu.",
                        ( unsigned long ) pFixedBuffer->size,
                        MQTT_DISCONNECT_PACKET_SIZE ) );
            status = MQTTNoMemory;
        }
    }

    if( status == MQTTSuccess )
    {
        pFixedBuffer->pBuffer[ 0 ] = MQTT_PACKET_TYPE_DISCONNECT;
        pFixedBuffer->pBuffer[ 1 ] = MQTT_DISCONNECT_REMAINING_LENGTH;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_GetPingreqPacketSize( size_t * pPacketSize )
{
    MQTTStatus_t status = MQTTSuccess;

    if( pPacketSize == NULL )
    {
        LogError( ( "pPacketSize is NULL." ) );
        status = MQTTBadParameter;
    }
    else
    {
        /* MQTT PINGREQ packets always have the same size. */
        *pPacketSize = MQTT_PACKET_PINGREQ_SIZE;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_SerializePingreq( const MQTTFixedBuffer_t * pFixedBuffer )
{
    MQTTStatus_t status = MQTTSuccess;

    if( pFixedBuffer == NULL )
    {
        LogError( ( "pFixedBuffer is NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pFixedBuffer->pBuffer == NULL )
    {
        LogError( ( "pFixedBuffer->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else
    {
        /* Empty else MISRA 15.7 */
    }

    if( status == MQTTSuccess )
    {
        if( pFixedBuffer->size < MQTT_PACKET_PINGREQ_SIZE )
        {
            LogError( ( "Buffer size of %lu is not sufficient to hold "
                        "serialized PINGREQ packet of size of %lu.",
                        ( unsigned long ) pFixedBuffer->size,
                        MQTT_PACKET_PINGREQ_SIZE ) );
            status = MQTTNoMemory;
        }
    }

    if( status == MQTTSuccess )
    {
        /* Ping request packets are always the same. */
        pFixedBuffer->pBuffer[ 0 ] = MQTT_PACKET_TYPE_PINGREQ;
        pFixedBuffer->pBuffer[ 1 ] = 0x00;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_DeserializePublish( const MQTTPacketInfo_t * pIncomingPacket,
                                      uint16_t * pPacketId,
                                      MQTTPublishInfo_t * pPublishInfo )
{
    MQTTStatus_t status = MQTTSuccess;

    if( ( pIncomingPacket == NULL ) || ( pPacketId == NULL ) || ( pPublishInfo == NULL ) )
    {
        LogError( ( "Argument cannot be NULL: pIncomingPacket=%p, "
                    "pPacketId=%p, pPublishInfo=%p",
                    ( void * ) pIncomingPacket,
                    ( void * ) pPacketId,
                    ( void * ) pPublishInfo ) );
        status = MQTTBadParameter;
    }
    else if( ( pIncomingPacket->type & 0xF0U ) != MQTT_PACKET_TYPE_PUBLISH )
    {
        LogError( ( "Packet is not publish. Packet type: %02x.",
                    ( unsigned int ) pIncomingPacket->type ) );
        status = MQTTBadParameter;
    }
    else if( pIncomingPacket->pRemainingData == NULL )
    {
        LogError( ( "Argument cannot be NULL: "
                    "pIncomingPacket->pRemainingData is NULL." ) );
        status = MQTTBadParameter;
    }
    else
    {
        status = deserializePublish( pIncomingPacket, pPacketId, pPublishInfo );
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_DeserializeConnAck( const MQTTPacketInfo_t * pIncomingPacket,
                                      bool * pSessionPresent,
                                      MQTTPropBuilder_t * pPropBuffer,
                                      MQTTConnectionProperties_t * pConnectProperties )
{
    MQTTStatus_t status = MQTTSuccess;

    if( pIncomingPacket == NULL )
    {
        LogError( ( "pIncomingPacket cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pConnectProperties == NULL )
    {
        LogError( ( "pConnectProperties cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pIncomingPacket->type != MQTT_PACKET_TYPE_CONNACK )
    {
        LogError( ( "MQTT_DeserializeConnAck should only be used to deserialize CONNACK packet." ) );
        status = MQTTBadParameter;
    }
    /* Pointer for session present cannot be NULL for CONNACK. */
    else if( pSessionPresent == NULL )
    {
        LogError( ( "pSessionPresent cannot be NULL for CONNACK packet." ) );
        status = MQTTBadParameter;
    }

    /* Pointer for remaining data cannot be NULL for packets other
     * than PINGRESP. */
    else if( pIncomingPacket->pRemainingData == NULL )
    {
        LogError( ( "Remaining data of incoming CONNACK packet is NULL." ) );
        status = MQTTBadParameter;
    }
    /* Max packet size cannot be 0. */
    else if( pConnectProperties->maxPacketSize == 0U )
    {
        LogError( ( "Max packet size cannot be 0." ) );
        status = MQTTBadParameter;
    }
    else if( ( pIncomingPacket->remainingLength +
               variableLengthEncodedSize( pIncomingPacket->remainingLength ) +
               1U ) > pConnectProperties->maxPacketSize )
    {
        LogError( ( "Incoming CONNACK packet Size cannot be greater than max packet size. " ) );
        status = MQTTBadResponse;
    }
    else
    {
        status = deserializeConnack( pConnectProperties,
                                     pIncomingPacket,
                                     pSessionPresent,
                                     pPropBuffer );
    }

    return status;
}

MQTTStatus_t MQTT_DeserializeAck( const MQTTPacketInfo_t * pIncomingPacket,
                                  uint16_t * pPacketId,
                                  bool * pSessionPresent )
{
    MQTTStatus_t status = MQTTSuccess;

    if( pIncomingPacket == NULL )
    {
        LogError( ( "pIncomingPacket cannot be NULL." ) );
        status = MQTTBadParameter;
    }

    /* Pointer for packet identifier cannot be NULL for packets other than
     * CONNACK and PINGRESP. */
    else if( ( pPacketId == NULL ) &&
             ( ( pIncomingPacket->type != MQTT_PACKET_TYPE_CONNACK ) &&
               ( pIncomingPacket->type != MQTT_PACKET_TYPE_PINGRESP ) ) )
    {
        LogError( ( "pPacketId cannot be NULL for packet type %02x.",
                    ( unsigned int ) pIncomingPacket->type ) );
        status = MQTTBadParameter;
    }
    /* Pointer for session present cannot be NULL for CONNACK. */
    else if( ( pSessionPresent == NULL ) &&
             ( pIncomingPacket->type == MQTT_PACKET_TYPE_CONNACK ) )
    {
        LogError( ( "pSessionPresent cannot be NULL for CONNACK packet." ) );
        status = MQTTBadParameter;
    }

    /* Pointer for remaining data cannot be NULL for packets other
     * than PINGRESP. */
    else if( ( pIncomingPacket->pRemainingData == NULL ) &&
             ( pIncomingPacket->type != MQTT_PACKET_TYPE_PINGRESP ) )
    {
        LogError( ( "Remaining data of incoming packet is NULL." ) );
        status = MQTTBadParameter;
    }
    else
    {
        /* Make sure response packet is a valid ack. */
        switch( pIncomingPacket->type )
        {
            case MQTT_PACKET_TYPE_CONNACK:
                LogError( ( "Connack should be deserialized with MQTT_DeserializeConnAck" ) );
                status = MQTTBadParameter;
                break;

            case MQTT_PACKET_TYPE_SUBACK:
                status = deserializeSuback( pIncomingPacket, pPacketId );
                break;

            case MQTT_PACKET_TYPE_PINGRESP:
                status = deserializePingresp( pIncomingPacket );
                break;

            case MQTT_PACKET_TYPE_UNSUBACK:
            case MQTT_PACKET_TYPE_PUBACK:
            case MQTT_PACKET_TYPE_PUBREC:
            case MQTT_PACKET_TYPE_PUBREL:
            case MQTT_PACKET_TYPE_PUBCOMP:
                status = deserializeSimpleAck( pIncomingPacket, pPacketId );
                break;

            /* Any other packet type is invalid. */
            default:
                LogError( ( "IotMqtt_DeserializeResponse() called with unknown packet type:(%02x).",
                            ( unsigned int ) pIncomingPacket->type ) );
                status = MQTTBadResponse;
                break;
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_GetIncomingPacketTypeAndLength( TransportRecv_t readFunc,
                                                  NetworkContext_t * pNetworkContext,
                                                  MQTTPacketInfo_t * pIncomingPacket )
{
    MQTTStatus_t status = MQTTSuccess;
    int32_t bytesReceived = 0;

    if( pIncomingPacket == NULL )
    {
        LogError( ( "Invalid parameter: pIncomingPacket is NULL." ) );
        status = MQTTBadParameter;
    }
    else
    {
        /* Read a single byte. */
        bytesReceived = readFunc( pNetworkContext,
                                  &( pIncomingPacket->type ),
                                  1U );
    }

    if( bytesReceived == 1 )
    {
        /* Check validity. */
        if( incomingPacketValid( pIncomingPacket->type ) == true )
        {
            pIncomingPacket->remainingLength = getRemainingLength( readFunc,
                                                                   pNetworkContext );

            if( pIncomingPacket->remainingLength == MQTT_REMAINING_LENGTH_INVALID )
            {
                LogError( ( "Incoming packet remaining length invalid." ) );
                status = MQTTBadResponse;
            }
        }
        else
        {
            LogError( ( "Incoming packet invalid: Packet type=%u.",
                        ( unsigned int ) pIncomingPacket->type ) );
            status = MQTTBadResponse;
        }
    }
    else if( ( status != MQTTBadParameter ) && ( bytesReceived == 0 ) )
    {
        status = MQTTNoDataAvailable;
    }

    /* If the input packet was valid, then any other number of bytes received is
     * a failure. */
    else if( status != MQTTBadParameter )
    {
        LogError( ( "A single byte was not read from the transport: "
                    "transportStatus=%ld.",
                    ( long int ) bytesReceived ) );
        status = MQTTRecvFailed;
    }
    else
    {
        /* Empty else MISRA 15.7 */
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_UpdateDuplicatePublishFlag( uint8_t * pHeader,
                                              bool set )
{
    MQTTStatus_t status = MQTTSuccess;

    if( pHeader == NULL )
    {
        LogError( ( "Header cannot be NULL" ) );
        status = MQTTBadParameter;
    }
    else if( ( ( *pHeader ) & 0xF0U ) != MQTT_PACKET_TYPE_PUBLISH )
    {
        LogError( ( "Header is not publish packet header" ) );
        status = MQTTBadParameter;
    }
    else if( set == true )
    {
        UINT8_SET_BIT( *pHeader, MQTT_PUBLISH_FLAG_DUP );
    }
    else
    {
        UINT8_CLEAR_BIT( *pHeader, MQTT_PUBLISH_FLAG_DUP );
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_ProcessIncomingPacketTypeAndLength( const uint8_t * pBuffer,
                                                      const size_t * pIndex,
                                                      MQTTPacketInfo_t * pIncomingPacket )
{
    MQTTStatus_t status = MQTTSuccess;

    if( pIncomingPacket == NULL )
    {
        LogError( ( "Invalid parameter: pIncomingPacket is NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pIndex == NULL )
    {
        LogError( ( "Invalid parameter: pIndex is NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pBuffer == NULL )
    {
        LogError( ( "Invalid parameter: pBuffer is NULL." ) );
        status = MQTTBadParameter;
    }
    /* There should be at least one byte in the buffer */
    else if( *pIndex < 1U )
    {
        /* No data is available. There are 0 bytes received from the network
         * receive function. */
        status = MQTTNoDataAvailable;
    }
    else
    {
        /* At least one byte is present which should be deciphered. */
        pIncomingPacket->type = pBuffer[ 0 ];
    }

    if( status == MQTTSuccess )
    {
        /* Check validity. */
        if( incomingPacketValid( pIncomingPacket->type ) == true )
        {
            status = processRemainingLength( pBuffer,
                                             pIndex,
                                             pIncomingPacket );
        }
        else
        {
            LogError( ( "Incoming packet invalid: Packet type=%u.",
                        ( unsigned int ) pIncomingPacket->type ) );
            status = MQTTBadResponse;
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_InitConnect( MQTTConnectionProperties_t * pConnectProperties )
{
    MQTTStatus_t status = MQTTSuccess;

    if( pConnectProperties == NULL )
    {
        LogError( ( "pConnectProperties cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else
    {
        pConnectProperties->receiveMax = UINT16_MAX;
        pConnectProperties->maxPacketSize = MQTT_MAX_PACKET_SIZE;
        pConnectProperties->requestProblemInfo = true;
        pConnectProperties->serverReceiveMax = UINT16_MAX;
        pConnectProperties->serverMaxQos = 2U;
        pConnectProperties->serverMaxPacketSize = MQTT_MAX_PACKET_SIZE;
        pConnectProperties->isWildcardAvailable = 1U;
        pConnectProperties->isSubscriptionIdAvailable = 1U;
        pConnectProperties->isSharedAvailable = 1U;
        pConnectProperties->sessionExpiry = 0U;
        pConnectProperties->topicAliasMax = 0U;
        pConnectProperties->requestResponseInfo = false;
        pConnectProperties->retainAvailable = 1U;
        pConnectProperties->serverTopicAliasMax = 0U;
        pConnectProperties->serverKeepAlive = UINT16_MAX;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropertyBuilder_Init( MQTTPropBuilder_t * pPropertyBuilder,
                                       uint8_t * buffer,
                                       size_t length )
{
    MQTTStatus_t status = MQTTSuccess;

    if( ( pPropertyBuilder == NULL ) || ( buffer == NULL ) || ( length == 0U ) )
    {
        LogError( ( "Invalid arguments passed to MQTTPropertyBuilder_Init. "
                    "pPropertyBuilder must be non-NULL; "
                    "buffer must be non-NULL; "
                    "and length must be non-zero. " ) );
        status = MQTTBadParameter;
    }

    if( status == MQTTSuccess )
    {
        pPropertyBuilder->pBuffer = buffer;
        pPropertyBuilder->currentIndex = 0;
        pPropertyBuilder->bufferLength = length;
        pPropertyBuilder->fieldSet = 0; /* 0 means no field is set. */
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_ValidateWillProperties( const MQTTPropBuilder_t * pPropertyBuilder )
{
    MQTTStatus_t status = MQTTSuccess;
    size_t propertyLength = 0U;
    uint8_t * pIndex = NULL;

    if( ( pPropertyBuilder == NULL ) || ( pPropertyBuilder->pBuffer == NULL ) )
    {
        status = MQTTBadParameter;
    }
    else
    {
        propertyLength = pPropertyBuilder->currentIndex;
        pIndex = pPropertyBuilder->pBuffer;
    }

    uint32_t propertyBitMask = 0;

    while( ( propertyLength > 0U ) && ( status == MQTTSuccess ) )
    {
        uint8_t propertyId = *pIndex;
        bool used = false;
        const char * data;
        uint16_t dataLength;

        pIndex = &pIndex[ 1 ];
        propertyLength -= sizeof( uint8_t );

        switch( propertyId )
        {
            case MQTT_WILL_DELAY_ID:
                if( UINT32_CHECK_BIT( propertyBitMask, MQTT_WILL_DELAY_POS ) != true )
                {
                    status = decodeUint32t( NULL, &propertyLength, &used, &pIndex );
                    UINT32_SET_BIT( propertyBitMask, MQTT_WILL_DELAY_POS );
                }
                else
                {
                    LogError( ( "Will Delay Interval included more than once in the properties." ) );
                    status = MQTTBadParameter;
                }
                break;

            case MQTT_PAYLOAD_FORMAT_ID:
                {
                    uint8_t property;
                    if( UINT32_CHECK_BIT( propertyBitMask, MQTT_PAYLOAD_FORMAT_INDICATOR_POS ) != true )
                    {
                        status = decodeUint8t( &property, &propertyLength, &used, &pIndex );
                        UINT32_SET_BIT( propertyBitMask, MQTT_PAYLOAD_FORMAT_INDICATOR_POS );
                    }
                    else
                    {
                        LogError( ( "Pauload format indicator included more than once in the properties." ) );
                        status = MQTTBadParameter;
                    }

                    if( status == MQTTSuccess )
                    {
                        if( ( property != 0 ) && ( property != 1 ) )
                        {
                            LogError( ( "Payload Format can only be 0 or 1 in will properties." ) );
                            status = MQTTBadParameter;
                        }
                    }
                }
                break;

            case MQTT_MSG_EXPIRY_ID:
                if( UINT32_CHECK_BIT( propertyBitMask, MQTT_MESSAGE_EXPIRY_INTERVAL_POS ) != true )
                {
                    status = decodeUint32t( NULL, &propertyLength, &used, &pIndex );
                    UINT32_SET_BIT( propertyBitMask, MQTT_MESSAGE_EXPIRY_INTERVAL_POS );
                }
                else
                {
                    LogError( ( "Message Expiry Interval included more than once in the properties." ) );
                    status = MQTTBadParameter;
                }
                break;

            case MQTT_CONTENT_TYPE_ID:
                if( UINT32_CHECK_BIT( propertyBitMask, MQTT_CONTENT_TYPE_POS ) != true )
                {
                    status = decodeUtf8( &data, &dataLength, &propertyLength, &used, &pIndex );
                    UINT32_SET_BIT( propertyBitMask, MQTT_CONTENT_TYPE_POS );
                }
                else
                {
                    LogError( ( "Content Type included more than once in the properties." ) );
                    status = MQTTBadParameter;
                }
                break;

            case MQTT_RESPONSE_TOPIC_ID:
                if( UINT32_CHECK_BIT( propertyBitMask, MQTT_RESPONSE_TOPIC_POS ) != true )
                {
                    status = decodeUtf8( &data, &dataLength, &propertyLength, &used, &pIndex );
                    UINT32_SET_BIT( propertyBitMask, MQTT_RESPONSE_TOPIC_POS );
                }
                else
                {
                    LogError( ( "Response topic included more than once in the properties." ) );
                    status = MQTTBadParameter;
                }
                break;

            case MQTT_CORRELATION_DATA_ID:
                if( UINT32_CHECK_BIT( propertyBitMask, MQTT_CORRELATION_DATA_POS ) != true )
                {
                    status = decodeUtf8( &data, &dataLength, &propertyLength, &used, &pIndex );
                    UINT32_SET_BIT( propertyBitMask, MQTT_CORRELATION_DATA_POS );
                }
                else
                {
                    LogError( ( "Corelation Data included more than once in the properties." ) );
                    status = MQTTBadParameter;
                }
                break;

            case MQTT_USER_PROPERTY_ID:
                {
                    const char * key, *value;
                    uint16_t keyLength, valueLength;
                    status = decodeUserProp( &key,
                                             &keyLength,
                                             &value,
                                             &valueLength,
                                             &propertyLength,
                                             &pIndex );
                }
                break;

            default:
                status = MQTTBadParameter;
                break;
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTT_ValidateConnectProperties( const MQTTPropBuilder_t * pPropertyBuilder,
                                             bool * isRequestProblemInfoSet )
{
    MQTTStatus_t status = MQTTSuccess;
    size_t propertyLength = 0U;
    uint8_t * pIndex = NULL;

    if( ( pPropertyBuilder == NULL ) || 
        ( pPropertyBuilder->pBuffer == NULL ) ||
        ( isRequestProblemInfoSet == NULL ) )
    {
        status = MQTTBadParameter;
    }
    else
    {
        propertyLength = pPropertyBuilder->currentIndex;
        pIndex = pPropertyBuilder->pBuffer;
        *isRequestProblemInfoSet = false;
    }

    uint32_t propertyBitMask = 0;

    while( ( propertyLength > 0U ) && ( status == MQTTSuccess ) )
    {
        uint8_t propertyId = *pIndex;
        bool used = false;
        const char * data;
        uint16_t dataLength;
            
        pIndex = &pIndex[ 1 ];
        propertyLength -= sizeof( uint8_t );

        switch( propertyId )
        {
            case MQTT_SESSION_EXPIRY_ID:
                if( UINT32_CHECK_BIT( propertyBitMask, MQTT_SESSION_EXPIRY_INTERVAL_POS ) != true )
                {
                    status = decodeUint32t( NULL, &propertyLength, &used, &pIndex );
                    UINT32_SET_BIT( propertyBitMask, MQTT_SESSION_EXPIRY_INTERVAL_POS );
                }
                else
                {
                    LogError( ( "Session Expiry Interval included more than once in the properties." ) );
                    status = MQTTBadParameter;
                }
                break;

            case MQTT_RECEIVE_MAX_ID:
                if( UINT32_CHECK_BIT( propertyBitMask, MQTT_RECEIVE_MAXIMUM_POS ) != true )
                {
                    uint16_t receiveMax;
                    status = decodeUint16t( &receiveMax, &propertyLength, &used, &pIndex );
                    UINT32_SET_BIT( propertyBitMask, MQTT_RECEIVE_MAXIMUM_POS );

                    if( status == MQTTSuccess )
                    {
                        if( receiveMax == 0U )
                        {
                            LogError( ( "Receive Maximum cannot be 0 in CONNECT properties." ) );
                            status = MQTTBadParameter;
                        }
                    }
                }
                else
                {
                    LogError( ( "Receive Maximum included more than once in the properties." ) );
                    status = MQTTBadParameter;
                }
                break;

            case MQTT_MAX_PACKET_SIZE_ID:
                if( UINT32_CHECK_BIT( propertyBitMask, MQTT_MAX_PACKET_SIZE_POS ) != true )
                {
                    uint32_t maxPacketSize;
                    status = decodeUint32t( &maxPacketSize, &propertyLength, &used, &pIndex );
                    UINT32_SET_BIT( propertyBitMask, MQTT_MAX_PACKET_SIZE_POS );

                    if( status == MQTTSuccess )
                    {
                        if( maxPacketSize == 0U )
                        {
                            LogError( ( "Maximum Packet Size cannot be 0 in CONNECT properties." ) );
                            status = MQTTBadParameter;
                        }
                    }
                }
                else
                {
                    LogError( ( "Maximum Packet Size included more than once in the properties." ) );
                    status = MQTTBadParameter;
                }
                break;

            case MQTT_TOPIC_ALIAS_MAX_ID:
                if( UINT32_CHECK_BIT( propertyBitMask, MQTT_TOPIC_ALIAS_MAX_POS ) != true )
                {
                    status = decodeUint16t( NULL, &propertyLength, &used, &pIndex );
                    UINT32_SET_BIT( propertyBitMask, MQTT_TOPIC_ALIAS_MAX_POS );
                }
                else
                {
                    LogError( ( "Topic Alias Maximum included more than once in the properties." ) );
                    status = MQTTBadParameter;
                }
                break;

            case MQTT_REQUEST_RESPONSE_ID:
                if( UINT32_CHECK_BIT( propertyBitMask, MQTT_REQUEST_RESPONSE_INFO_POS ) != true )
                {
                    uint8_t requestResponseInfo;
                    status = decodeUint8t( &requestResponseInfo, &propertyLength, &used, &pIndex );
                    UINT32_SET_BIT( propertyBitMask, MQTT_REQUEST_RESPONSE_INFO_POS );

                    if( status == MQTTSuccess )
                    {
                        if( ( requestResponseInfo != 0U ) && ( requestResponseInfo != 1U ) )
                        {
                            LogError( ( "Request Response Information can only be 0 or 1 in CONNECT properties." ) );
                            status = MQTTBadParameter;
                        }
                    }
                }
                else
                {
                    LogError( ( "Request Response Information included more than once in the properties." ) );
                    status = MQTTBadParameter;
                }
                break;

            case MQTT_REQUEST_PROBLEM_ID:
                if( UINT32_CHECK_BIT( propertyBitMask, MQTT_REQUEST_PROBLEM_INFO_POS ) != true )
                {
                    uint8_t requestProblemInfo;
                    status = decodeUint8t( &requestProblemInfo, &propertyLength, &used, &pIndex );
                    UINT32_SET_BIT( propertyBitMask, MQTT_REQUEST_PROBLEM_INFO_POS );

                    if( status == MQTTSuccess )
                    {
                        if( ( requestProblemInfo != 0U ) && ( requestProblemInfo != 1U ) )
                        {
                            LogError( ( "Request Problem Information can only be 0 or 1 in CONNECT properties." ) );
                            status = MQTTBadParameter;
                        }
                        else
                        {
                            *isRequestProblemInfoSet = ( requestProblemInfo == 1U );
                        }
                    }
                }
                else
                {
                    LogError( ( "Request Problem Information included more than once in the properties." ) );
                    status = MQTTBadParameter;
                }
                break;

            case MQTT_AUTH_METHOD_ID:
                if( UINT32_CHECK_BIT( propertyBitMask, MQTT_AUTHENTICATION_METHOD_POS ) != true )
                {
                    status = decodeUtf8( &data, &dataLength, &propertyLength, &used, &pIndex );
                    UINT32_SET_BIT( propertyBitMask, MQTT_AUTHENTICATION_METHOD_POS );
                }
                else
                {
                    LogError( ( "Authentication Method included more than once in the properties." ) );
                    status = MQTTBadParameter;
                }
                break;

            case MQTT_AUTH_DATA_ID:
                if( UINT32_CHECK_BIT( propertyBitMask, MQTT_AUTHENTICATION_DATA_POS ) != true )
                {
                    status = decodeUtf8( &data, &dataLength, &propertyLength, &used, &pIndex );
                    UINT32_SET_BIT( propertyBitMask, MQTT_AUTHENTICATION_DATA_POS );
                }
                else
                {
                    LogError( ( "Authentication Data included more than once in the properties." ) );
                    status = MQTTBadParameter;
                }
                break;

            case MQTT_USER_PROPERTY_ID:
                {
                    const char * key, * value;
                    uint16_t keyLength, valueLength;
                    status = decodeUserProp( &key,
                                             &keyLength,
                                             &value,
                                             &valueLength,
                                             &propertyLength,
                                             &pIndex );
                }
                break;

            default:
                LogError( ( "Invalid property ID 0x%02x in CONNECT properties.", propertyId ) );
                status = MQTTBadParameter;
                break;
        }
    }

    if(status == MQTTSuccess )
    {
        if( ( UINT32_CHECK_BIT( propertyBitMask, MQTT_AUTHENTICATION_DATA_POS ) == true ) && 
            ( UINT32_CHECK_BIT( propertyBitMask, MQTT_AUTHENTICATION_METHOD_POS ) != true ) )
        {
            LogError( ( "Authentication data added but no authentication method present in CONNECT properties." ) );
            status = MQTTBadParameter;
        }
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_SubscribeId( MQTTPropBuilder_t * pPropertyBuilder,
                                      size_t subscriptionId,
                                      const uint8_t * pOptionalMqttPacketType )
{
    MQTTStatus_t status = MQTTSuccess;
    uint8_t * pIndex;

    if( subscriptionId == 0U )
    {
        LogError( ( "Subscription Id cannot be 0 for subscribe properties: Protocol Error." ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder == NULL )
    {
        LogError( ( "Argument pPropertyBuilder cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Argument pPropertyBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_SUBSCRIPTION_ID_POS ) )
    {
        LogError( ( "Subscription Id already set." ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_SUBSCRIPTION_ID_POS ) == false ) )
    {
        LogError( ( "Subscription Id not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint8_t ) +
               variableLengthEncodedSize( subscriptionId ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add subscription id." ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_SUBSCRIPTION_ID_ID;
        pIndex++;
        pIndex = encodeVariableLength( pIndex, subscriptionId );
        /* More details at: https://github.com/FreeRTOS/coreMQTT/blob/main/MISRA.md#rule-108 */
        /* coverity[misra_c_2012_rule_10_8_violation] */
        pPropertyBuilder->currentIndex += ( size_t ) ( pIndex - &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ] );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_SUBSCRIPTION_ID_POS );
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_UserProp( MQTTPropBuilder_t * pPropertyBuilder,
                                   const MQTTUserProperty_t * userProperty,
                                   const uint8_t * pOptionalMqttPacketType )
{
    MQTTStatus_t status = MQTTSuccess;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Argument pPropertyBuilder cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Argument pPropertyBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( userProperty == NULL )
    {
        LogError( ( "Argument userProperty cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( ( userProperty->pKey == NULL ) ||
             ( userProperty->pValue == NULL ) ||
             ( userProperty->keyLength == 0U ) ||
             ( userProperty->valueLength == 0U ) )
    {
        LogError( ( "Arguments cannot be NULL: pUserProperties->userProperty->pKey=%p, "
                    "pUserProperties->userProperty->pValue=%p, "
                    "Key Length = %u, Value Length = %u",
                    ( void * ) userProperty->pKey,
                    ( void * ) userProperty->pValue,
                    userProperty->keyLength,
                    userProperty->valueLength ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_USER_PROP_POS ) == false ) )
    {
        LogError( ( "User property not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + userProperty->keyLength +
               userProperty->valueLength + sizeof( uint16_t ) + sizeof( uint16_t ) +
               sizeof( uint8_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property." ) );
        status = MQTTNoMemory;
    }
    else
    {
        const uint8_t * start = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        uint8_t * pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];

        *pIndex = MQTT_USER_PROPERTY_ID;
        pIndex++;

        /* Encoding key. */
        pIndex = encodeString( pIndex, userProperty->pKey, userProperty->keyLength );
        pIndex = encodeString( pIndex, userProperty->pValue, userProperty->valueLength );
        /* More details at: https://github.com/FreeRTOS/coreMQTT/blob/main/MISRA.md#rule-108 */
        /* coverity[misra_c_2012_rule_10_8_violation] */
        pPropertyBuilder->currentIndex += ( size_t ) ( pIndex - start );
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_SessionExpiry( MQTTPropBuilder_t * pPropertyBuilder,
                                        uint32_t sessionExpiry,
                                        const uint8_t * pOptionalMqttPacketType )
{
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Arguments cannot be NULL : pPropertyBuilder=%p.", ( void * ) pPropertyBuilder ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Arguments cannot be NULL : pPropertyBuilder->pBuffer=%p.",
                    ( void * ) pPropertyBuilder->pBuffer ) );
        status = MQTTBadParameter;
    }
    else if( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_SESSION_EXPIRY_INTERVAL_POS ) )
    {
        LogError( ( "Connect Session Expiry Already Set" ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_SESSION_EXPIRY_INTERVAL_POS ) == false ) )
    {
        LogError( ( "Connect Session Expiry not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint32_t ) + sizeof( uint8_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property" ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_SESSION_EXPIRY_ID;
        pIndex++;
        WRITE_UINT32( &( pIndex[ 0 ] ), sessionExpiry );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_SESSION_EXPIRY_INTERVAL_POS );
        pPropertyBuilder->currentIndex += 5U;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_ConnReceiveMax( MQTTPropBuilder_t * pPropertyBuilder,
                                         uint16_t receiveMax,
                                         const uint8_t * pOptionalMqttPacketType )
{
    MQTTStatus_t status = MQTTSuccess;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Argument pPropertyBuilder cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Argument pPropertyBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( ( receiveMax == 0U ) || ( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_RECEIVE_MAXIMUM_POS ) ) )
    {
        LogError( ( "Invalid arguments passed to MQTTPropAdd_ConnReceiveMax." ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_RECEIVE_MAXIMUM_POS ) == false ) )
    {
        LogError( ( "Receive Maximum not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint16_t ) +
               sizeof( uint8_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property." ) );
        status = MQTTNoMemory;
    }
    else
    {
        uint8_t * pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_RECEIVE_MAX_ID;
        pIndex++;
        pIndex[ 0 ] = UINT16_HIGH_BYTE( receiveMax );
        pIndex[ 1 ] = UINT16_LOW_BYTE( receiveMax );
        pIndex = &pIndex[ 2 ];
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_RECEIVE_MAXIMUM_POS );
        pPropertyBuilder->currentIndex += 3U;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_ConnMaxPacketSize( MQTTPropBuilder_t * pPropertyBuilder,
                                            uint32_t maxPacketSize,
                                            const uint8_t * pOptionalMqttPacketType )
{
    MQTTStatus_t status = MQTTSuccess;
    uint8_t * pIndex;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Argument pPropertyBuilder cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Argument pPropertyBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( maxPacketSize == 0U )
    {
        LogError( ( "Max packet size cannot be set to 0." ) );
        status = MQTTBadParameter;
    }
    else if( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_MAX_PACKET_SIZE_POS ) )
    {
        LogError( ( "Max packet size already set." ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_MAX_PACKET_SIZE_POS ) == false ) )
    {
        LogError( ( "Max packet size not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint32_t ) +
               sizeof( uint8_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property" ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_MAX_PACKET_SIZE_ID;
        pIndex++;
        WRITE_UINT32( &( pIndex[ 0 ] ), maxPacketSize );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_MAX_PACKET_SIZE_POS );
        pPropertyBuilder->currentIndex += 5U;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_ConnTopicAliasMax( MQTTPropBuilder_t * pPropertyBuilder,
                                            uint16_t topicAliasMax,
                                            const uint8_t * pOptionalMqttPacketType )
{
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Arguments cannot be NULL : pPropertyBuilder=%p.", ( void * ) pPropertyBuilder ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Arguments cannot be NULL : pPropertyBuilder->pBuffer=%p.",
                    ( void * ) pPropertyBuilder->pBuffer ) );
        status = MQTTBadParameter;
    }
    else if( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_TOPIC_ALIAS_MAX_POS ) )
    {
        LogError( ( "Topic Alias Maximum already set. " ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_TOPIC_ALIAS_MAX_POS ) == false ) )
    {
        LogError( ( "Topic Alias Maximum not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint16_t ) +
               sizeof( uint8_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property" ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_TOPIC_ALIAS_MAX_ID;
        pIndex++;
        pIndex[ 0 ] = UINT16_HIGH_BYTE( topicAliasMax );
        pIndex[ 1 ] = UINT16_LOW_BYTE( topicAliasMax );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_TOPIC_ALIAS_MAX_POS );
        pPropertyBuilder->currentIndex += 3U;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_ConnRequestRespInfo( MQTTPropBuilder_t * pPropertyBuilder,
                                              bool requestResponseInfo,
                                              const uint8_t * pOptionalMqttPacketType )
{
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Arguments cannot be NULL : pPropertyBuilder=%p.", ( void * ) pPropertyBuilder ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Arguments cannot be NULL : pPropertyBuilder->pBuffer=%p.",
                    ( void * ) pPropertyBuilder->pBuffer ) );
        status = MQTTBadParameter;
    }
    else if( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_REQUEST_RESPONSE_INFO_POS ) )
    {
        LogError( ( "Request Response Info already set." ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_REQUEST_RESPONSE_INFO_POS ) == false ) )
    {
        LogError( ( "Request Response Info not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint8_t ) +
               sizeof( uint8_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property" ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_REQUEST_RESPONSE_ID;
        pIndex++;
        *pIndex = ( requestResponseInfo ? 1U : 0U );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_REQUEST_RESPONSE_INFO_POS );
        pPropertyBuilder->currentIndex += 2U;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_ConnRequestProbInfo( MQTTPropBuilder_t * pPropertyBuilder,
                                              bool requestProblemInfo,
                                              const uint8_t * pOptionalMqttPacketType )
{
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Argument pPropertyBuilder cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Argument pPropertyBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_REQUEST_PROBLEM_INFO_POS ) )
    {
        LogError( ( "Request Problem Info already set." ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_REQUEST_PROBLEM_INFO_POS ) == false ) )
    {
        LogError( ( "Request Problem Info not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint8_t ) +
               sizeof( uint8_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property." ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_REQUEST_RESPONSE_ID;
        pIndex++;
        *pIndex = ( requestProblemInfo ? 1U : 0U );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_REQUEST_PROBLEM_INFO_POS );
        pPropertyBuilder->currentIndex += 2U;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_ConnAuthMethod( MQTTPropBuilder_t * pPropertyBuilder,
                                         const char * authMethod,
                                         uint16_t authMethodLength,
                                         const uint8_t * pOptionalMqttPacketType )
{
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    if( ( pPropertyBuilder == NULL ) || ( authMethod == NULL ) || ( authMethodLength == 0U ) )
    {
        LogError( ( "Arguments cannot be NULL: pPropertyBuilder=%p, authMethod = %p, authMethodLength = %u", ( void * ) pPropertyBuilder, ( void * ) authMethod, authMethodLength ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Argument pPropertyBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_AUTHENTICATION_METHOD_POS ) )
    {
        LogError( ( "Auth Method already set." ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_AUTHENTICATION_METHOD_POS ) == false ) )
    {
        LogError( ( "Auth Method not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint8_t ) + authMethodLength +
               sizeof( uint16_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property." ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_AUTH_METHOD_ID;
        pIndex++;
        pIndex = encodeString( pIndex, authMethod, authMethodLength );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_AUTHENTICATION_METHOD_POS );
        /* More details at: https://github.com/FreeRTOS/coreMQTT/blob/main/MISRA.md#rule-108 */
        /* coverity[misra_c_2012_rule_10_8_violation] */
        pPropertyBuilder->currentIndex += ( size_t ) ( pIndex - ( &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ] ) );
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_ConnAuthData( MQTTPropBuilder_t * pPropertyBuilder,
                                       const char * authData,
                                       uint16_t authDataLength,
                                       const uint8_t * pOptionalMqttPacketType )
{
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    if( ( pPropertyBuilder == NULL ) || ( authData == NULL ) || ( authDataLength == 0U ) )
    {
        LogError( ( "Arguments cannot be NULL : pPropertyBuilder=%p, authMethod = %p, authMethodLength = %u",
                    ( void * ) pPropertyBuilder, ( void * ) authData, authDataLength ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Argument pPropertyBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint8_t ) + authDataLength +
               sizeof( uint16_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property." ) );
        status = MQTTNoMemory;
    }
    else if( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_AUTHENTICATION_METHOD_POS ) == false )
    {
        LogError( ( "Auth method must be added before authentication data. "
                    "Not a protocol violation but a practice enforced by coreMQTT." ) );
        status = MQTTBadParameter;
    }
    else if( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_AUTHENTICATION_DATA_POS ) )
    {
        LogError( ( "Invalid Auth data." ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_AUTHENTICATION_DATA_POS ) == false ) )
    {
        LogError( ( "Auth data not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_AUTH_DATA_ID;
        pIndex++;
        pIndex = encodeString( pIndex, authData, authDataLength );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_AUTHENTICATION_DATA_POS );
        /* More details at: https://github.com/FreeRTOS/coreMQTT/blob/main/MISRA.md#rule-108 */
        /* coverity[misra_c_2012_rule_10_8_violation] */
        pPropertyBuilder->currentIndex += ( size_t ) ( pIndex - ( &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ] ) );
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_PubPayloadFormat( MQTTPropBuilder_t * pPropertyBuilder,
                                           bool payloadFormat,
                                           const uint8_t * pOptionalMqttPacketType )
{
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Argument pPropertyBuilder cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Argument pPropertyBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( ( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_PAYLOAD_FORMAT_INDICATOR_POS ) ) )
    {
        LogError( ( "Payload Format already set." ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_PAYLOAD_FORMAT_INDICATOR_POS ) == false ) )
    {
        LogError( ( "Payload Format not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint8_t ) +
               sizeof( uint8_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property." ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_PAYLOAD_FORMAT_ID;
        pIndex++;
        *pIndex = ( uint8_t ) ( payloadFormat ? 1U : 0U );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_PAYLOAD_FORMAT_INDICATOR_POS );
        pPropertyBuilder->currentIndex += 2U;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_PubMessageExpiry( MQTTPropBuilder_t * pPropertyBuilder,
                                           uint32_t messageExpiry,
                                           const uint8_t * pOptionalMqttPacketType )
{
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Argument pPropertyBuilder cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Argument pPropertyBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( ( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_MESSAGE_EXPIRY_INTERVAL_POS ) ) )
    {
        LogError( ( "Message Expiry Interval already set." ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_MESSAGE_EXPIRY_INTERVAL_POS ) == false ) )
    {
        LogError( ( "Message Expiry Interval not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint32_t ) +
               sizeof( uint8_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property." ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_MSG_EXPIRY_ID;
        pIndex++;
        WRITE_UINT32( &( pIndex[ 0 ] ), messageExpiry );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_MESSAGE_EXPIRY_INTERVAL_POS );
        pPropertyBuilder->currentIndex += 5U;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_WillDelayInterval( MQTTPropBuilder_t * pPropertyBuilder,
                                            uint32_t willDelayInterval,
                                            const uint8_t * pOptionalMqttPacketType )
{
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Argument pPropertyBuilder cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Argument pPropertyBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( ( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_WILL_DELAY_POS ) ) )
    {
        LogError( ( "Message Expiry Interval already set." ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_WILL_DELAY_POS ) == false ) )
    {
        LogError( ( "Message Expiry Interval not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint32_t ) +
               sizeof( uint8_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property." ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_WILL_DELAY_ID;
        pIndex++;
        WRITE_UINT32( &( pIndex[ 0 ] ), willDelayInterval );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_WILL_DELAY_POS );
        pPropertyBuilder->currentIndex += 5U;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_PubTopicAlias( MQTTPropBuilder_t * pPropertyBuilder,
                                        uint16_t topicAlias,
                                        const uint8_t * pOptionalMqttPacketType )
{
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Arguments cannot be NULL : pPropertyBuilder=%p.", ( void * ) pPropertyBuilder ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Arguments cannot be NULL : pPropertyBuilder->pBuffer=%p.",
                    ( void * ) pPropertyBuilder->pBuffer ) );
        status = MQTTBadParameter;
    }
    else if( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_TOPIC_ALIAS_POS ) )
    {
        LogError( ( "TopicAlias already present" ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_TOPIC_ALIAS_POS ) == false ) )
    {
        LogError( ( "TopicAlias not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( topicAlias == 0U )
    {
        LogError( ( "Topic Alias cannot be 0" ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint16_t ) +
               sizeof( uint8_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property" ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_TOPIC_ALIAS_ID;
        pIndex++;
        pIndex[ 0 ] = UINT16_HIGH_BYTE( topicAlias );
        pIndex[ 1 ] = UINT16_LOW_BYTE( topicAlias );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_TOPIC_ALIAS_POS );
        pPropertyBuilder->currentIndex += 3U;
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_PubResponseTopic( MQTTPropBuilder_t * pPropertyBuilder,
                                           const char * responseTopic,
                                           uint16_t responseTopicLength,
                                           const uint8_t * pOptionalMqttPacketType )
{
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Argument pPropertyBuilder cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Argument pPropertyBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( responseTopic == NULL )
    {
        LogError( ( "Argument responseTopic cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( responseTopicLength == 0U )
    {
        LogError( ( "Response Topic Length cannot be 0" ) );
        status = MQTTBadParameter;
    }
    else if( ( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_RESPONSE_TOPIC_POS ) ) )
    {
        LogError( ( "Response Topic already set" ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_RESPONSE_TOPIC_POS ) == false ) )
    {
        LogError( ( "Response Topic not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( strchr( responseTopic, ( int32_t ) '#' ) != NULL ) ||
             ( strchr( responseTopic, ( int32_t ) '+' ) != NULL ) )
    {
        LogError( ( "Protocol Error: Response Topic contains wildcards." ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint8_t ) + responseTopicLength +
               sizeof( uint16_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property." ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_RESPONSE_TOPIC_ID;
        pIndex++;
        pIndex = encodeString( pIndex, responseTopic, responseTopicLength );
        /* More details at: https://github.com/FreeRTOS/coreMQTT/blob/main/MISRA.md#rule-108 */
        /* coverity[misra_c_2012_rule_10_8_violation] */
        pPropertyBuilder->currentIndex += ( size_t ) ( pIndex - ( &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ] ) );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_RESPONSE_TOPIC_POS );
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_PubCorrelationData( MQTTPropBuilder_t * pPropertyBuilder,
                                             const void * pCorrelationData,
                                             uint16_t correlationLength,
                                             const uint8_t * pOptionalMqttPacketType )
{
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Argument pPropertyBuilder cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Argument pPropertyBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pCorrelationData == NULL )
    {
        LogError( ( "Argument pCorrelationData cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( correlationLength == 0U )
    {
        LogError( ( "Correlation Data Length cannot be 0." ) );
        status = MQTTBadParameter;
    }
    else if( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_CORRELATION_DATA_POS ) )
    {
        LogError( ( "Correlation Data already set." ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_CORRELATION_DATA_POS ) == false ) )
    {
        LogError( ( "Correlation Data not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint8_t ) + correlationLength +
               sizeof( uint16_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property." ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_CORRELATION_DATA_ID;
        pIndex++;
        pIndex = encodeBinaryData( pIndex, pCorrelationData, correlationLength );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_CORRELATION_DATA_POS );
        /* More details at: https://github.com/FreeRTOS/coreMQTT/blob/main/MISRA.md#rule-108 */
        /* coverity[misra_c_2012_rule_10_8_violation] */
        pPropertyBuilder->currentIndex += ( size_t ) ( pIndex - ( &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ] ) );
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_PubContentType( MQTTPropBuilder_t * pPropertyBuilder,
                                         const char * contentType,
                                         uint16_t contentTypeLength,
                                         const uint8_t * pOptionalMqttPacketType )
{
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Argument pPropertyBuilder cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Argument pPropertyBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( contentType == NULL )
    {
        LogError( ( "Argument contentType cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( contentTypeLength == 0U )
    {
        LogError( ( "Content Type Length cannot be 0." ) );
        status = MQTTBadParameter;
    }
    else if( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_CONTENT_TYPE_POS ) )
    {
        LogError( ( "Content type already set" ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_CONTENT_TYPE_POS ) == false ) )
    {
        LogError( ( "Content type not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint8_t ) + contentTypeLength +
               sizeof( uint16_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property." ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_CONTENT_TYPE_ID;
        pIndex++;
        pIndex = encodeString( pIndex, contentType, contentTypeLength );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_CONTENT_TYPE_POS );
        /* More details at: https://github.com/FreeRTOS/coreMQTT/blob/main/MISRA.md#rule-108 */
        /* coverity[misra_c_2012_rule_10_8_violation] */
        pPropertyBuilder->currentIndex += ( size_t ) ( pIndex - ( &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ] ) );
    }

    return status;
}

/*-----------------------------------------------------------*/

MQTTStatus_t MQTTPropAdd_ReasonString( MQTTPropBuilder_t * pPropertyBuilder,
                                       const char * pReasonString,
                                       uint16_t reasonStringLength,
                                       const uint8_t * pOptionalMqttPacketType )
{
    uint8_t * pIndex;
    MQTTStatus_t status = MQTTSuccess;

    if( pPropertyBuilder == NULL )
    {
        LogError( ( "Argument pPropertyBuilder cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pPropertyBuilder->pBuffer == NULL )
    {
        LogError( ( "Argument pPropertyBuilder->pBuffer cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( pReasonString == NULL )
    {
        LogError( ( "Argument pReasonString cannot be NULL." ) );
        status = MQTTBadParameter;
    }
    else if( reasonStringLength == 0U )
    {
        LogError( ( "Reason String Length cannot be 0." ) );
        status = MQTTBadParameter;
    }
    else if( UINT32_CHECK_BIT( pPropertyBuilder->fieldSet, MQTT_REASON_STRING_POS ) )
    {
        LogError( ( "Reason String already set." ) );
        status = MQTTBadParameter;
    }
    else if( ( pOptionalMqttPacketType != NULL ) &&
             ( isValidPropertyInPacketType( pOptionalMqttPacketType, MQTT_REASON_STRING_POS ) == false ) )
    {
        LogError( ( "Reason String not allowed in %d packet type.", *pOptionalMqttPacketType ) );
        status = MQTTBadParameter;
    }
    else if( ( pPropertyBuilder->currentIndex + sizeof( uint8_t ) + reasonStringLength +
               sizeof( uint16_t ) ) > pPropertyBuilder->bufferLength )
    {
        LogError( ( "Buffer too small to add property." ) );
        status = MQTTNoMemory;
    }
    else
    {
        pIndex = &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ];
        *pIndex = MQTT_REASON_STRING_ID;
        pIndex++;
        pIndex = encodeString( pIndex, pReasonString, reasonStringLength );
        UINT32_SET_BIT( pPropertyBuilder->fieldSet, MQTT_REASON_STRING_POS );
        /* More details at: https://github.com/FreeRTOS/coreMQTT/blob/main/MISRA.md#rule-108 */
        /* coverity[misra_c_2012_rule_10_8_violation] */
        pPropertyBuilder->currentIndex += ( size_t ) ( pIndex - ( &pPropertyBuilder->pBuffer[ pPropertyBuilder->currentIndex ] ) );
    }

    return status;
}

/*-----------------------------------------------------------*/
